<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bridge——桥接器模式</title>
    <url>/2022/05/05/Bridge/</url>
    <content><![CDATA[<h3 id="background">Background</h3>
<p>作为某互联网公司员工的小明，最近接到上司安排的一个任务，要求他为一个奶茶店开发一个微信小程序。小明的开发非常顺利，目前正在开发点单系统。</p>
<p>奶茶的品类数不胜数，规格大同小异：</p>
<ul>
<li>容量有小杯、中杯、大杯三种</li>
<li>小料有冰淇凌、多肉、椰果、珍珠四种</li>
</ul>
<p>小明在草稿纸上如丝滑地书写他的思路：</p>
<p><img src="/2022/05/05/Bridge/image-20220505110526874.png" alt="image-20220505110526874" style="zoom:80%;"></p>
<p>很快，12种规格清晰地出现在他面前，小明根据思路进行了代码编写，很快就完成了任务</p>
<p>但是好景不长，在运维的过程中，商家突然要求增加一种新的容量：超大杯(市场形势所迫)，且要求增加两种新的属性</p>
<ul>
<li>温度为去冰、少冰、中冰</li>
<li>甜度为三分糖、五分糖、七分糖、全糖</li>
</ul>
<p>这下小明崩溃了，按照商家的要求，至少需要将原有的<strong>12种规格</strong>(3
* 4)扩展为<strong>144种规格</strong>(3 * 4 * 3 * 4)
，而且让小明更绝望的是，一旦商家再次要求<strong>新增属性，规格的数量相成倍上升</strong>。</p>
<p>无可奈何的小明去请教了业务经验更为丰富的小红，小红帮助小明重新规划了思路：</p>
<p><img src="/2022/05/05/Bridge/image-20220505121241002.png" alt="image-20220505121241002" style="zoom:80%;"></p>
<p>小明恍然大悟：用这种方法，无论商家要求增加属性，或是属性的条目数，都<strong>只需要新增类而无需改动其他代码了</strong>！</p>
<blockquote>
<p>上述案例改编于实际业务，属于桥接器模式的一方面应用，充分体现了桥接器模式的好处</p>
</blockquote>
<h3 id="bridge">Bridge</h3>
<p><strong>将抽象与实现分离，使它们都可以独立地变化</strong>，可以方便地对每个部分<strong>独立</strong>修改、扩充和重用</p>
<p><strong>适用情况举例</strong>：</p>
<ol type="1">
<li>绘制形状：需要画蓝色/红色/黄色/...的圆形/长方形/正方形</li>
<li>选择画笔：选择大小为10px/12px/...的铅笔/钢笔/毛笔</li>
<li>游戏怪物：生成属性为水/火/......的无相怪物/丘丘萨满/史莱姆</li>
</ol>
<p>可以发现桥接模式比较适用于拥有二维以上属性，并需要动态变化、扩展的情况</p>
<blockquote>
<p>注意：在二维以上的情况，需要结合<strong>适配器</strong>适用，或是<strong>损失部分松散耦合</strong></p>
</blockquote>
<h3 id="example">Example</h3>
<p>书写上回，看一下如何实现小红的构想</p>
<blockquote>
<p><a href="https://github.com/relink2021/DesignPatternHomework/tree/master/src/Homework9/milkTea">完整代码</a></p>
</blockquote>
<ul>
<li>首先有一个奶茶配置接口类，用于管理奶茶的各种配置信息：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 奶茶配置接口</span></span><br><span class="line"><span class="comment"> * 1.温度</span></span><br><span class="line"><span class="comment"> * 2.加料</span></span><br><span class="line"><span class="comment"> * 3.甜度</span></span><br><span class="line"><span class="comment"> * 牺牲了一定松散耦合，获取更多属性的桥接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MilkTeaImp</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假设商家要新增大小属性</span></span><br><span class="line"><span class="comment">     * private static SizeImp sizeImp;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IceImp iceImp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AddImp addImp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SweetnessImp sweetnessImp;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MilkTeaImp</span><span class="params">(IceImp iceImp, AddImp addImp, SweetnessImp sweetnessImp<span class="comment">/*, SizeImp sizeImp*/</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.iceImp = iceImp;</span><br><span class="line">        <span class="built_in">this</span>.addImp = addImp;</span><br><span class="line">        <span class="built_in">this</span>.sweetnessImp = sweetnessImp;</span><br><span class="line">        <span class="comment">/* this.sizeImp = sizeImp */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面是getter和setter</span></span><br><span class="line">    get();set();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>看看三个接口都有什么用：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 甜度接口，有以下几类：</span></span><br><span class="line"><span class="comment"> * 1.三分糖</span></span><br><span class="line"><span class="comment"> * 2.五分糖</span></span><br><span class="line"><span class="comment"> * 3.七分糖</span></span><br><span class="line"><span class="comment"> * 4.全糖</span></span><br><span class="line"><span class="comment"> * 需要添加新的甜度直接在包中添加新类并继承该类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SweetnessImp</span> &#123;</span><br><span class="line">    <span class="comment">// 设置甜度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setSweetness</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加料接口，有以下几类：</span></span><br><span class="line"><span class="comment"> * 1.冰淇凌</span></span><br><span class="line"><span class="comment"> * 2.多肉</span></span><br><span class="line"><span class="comment"> * 3.珍珠</span></span><br><span class="line"><span class="comment"> * 需要添加新的小料直接在包中添加新类并继承该类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AddImp</span> &#123;</span><br><span class="line">    <span class="comment">// 添加小料</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourMaterial</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 温度接口，有以下几类：</span></span><br><span class="line"><span class="comment"> * 1.去冰</span></span><br><span class="line"><span class="comment"> * 2.少冰</span></span><br><span class="line"><span class="comment"> * 3.中冰</span></span><br><span class="line"><span class="comment"> * 需要添加新的温度直接在包中添加新类并继承该类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">IceImp</span> &#123;</span><br><span class="line">    <span class="comment">// 放冰块(调节温度)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourIce</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 如果要求实现大小接口的写法</span></span><br><span class="line"><span class="comment">public abstract class SizeImp &#123;</span></span><br><span class="line"><span class="comment">	// 选择大小</span></span><br><span class="line"><span class="comment">    public abstract void setSize();</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>接下来是抽象的奶茶类(因为奶茶有很多种，后面有具体实现)：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类奶茶，有两个作用</span></span><br><span class="line"><span class="comment"> * 1.配置MilkTeaImp接口</span></span><br><span class="line"><span class="comment"> * 2.规定模板方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MilkTea</span> &#123;</span><br><span class="line">    MilkTeaImp milkTeaImp;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMilkTeaImp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.milkTeaImp = MilkTeaSingleton.getMilkTeaImp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> MilkTeaImp <span class="title function_">getMilkTeaImp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.milkTeaImp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeMilkTea</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法模式：规定奶茶制作顺序</span></span><br><span class="line"><span class="comment">     * 商家如果有额外属性要求，配置要属性后在此处新增获取接口即可</span></span><br><span class="line"><span class="comment">     * 1.先获得各个子接口类(配方)</span></span><br><span class="line"><span class="comment">     * 2.然后由子类制作不同奶茶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取温度接口</span></span><br><span class="line">        getMilkTeaImp().getIceImp().pourIce();</span><br><span class="line">        <span class="comment">// 获取加料接口</span></span><br><span class="line">        getMilkTeaImp().getAddImp().pourMaterial();</span><br><span class="line">        <span class="comment">// 获取甜度接口</span></span><br><span class="line">        getMilkTeaImp().getSweetnessImp().setSweetness();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 假定商家要新增奶茶属性：大杯/中杯/小杯，获取大小接口：</span></span><br><span class="line"><span class="comment">         * getMilkTeaImp().getSizeImp().setSize();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 制作奶茶</span></span><br><span class="line">        makeMilkTea();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>在特定情况下需要保证奶茶配置接口唯一，使用单例模式实现</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确保MilkTea唯一</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MilkTeaSingleton</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> MilkTeaImp milkTeaImp;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">MilkTeaSingleton</span><span class="params">(MilkTeaImp milkTeaImp)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.milkTeaImp = milkTeaImp;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> MilkTeaImp <span class="title function_">getMilkTeaImp</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> milkTeaImp;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>下面是具体的实现类，只举例说明，详细代码见<a href="https://github.com/relink2021/DesignPatternHomework/tree/master/src/Homework9/milkTea">GitHub仓库</a></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加料实现类：加冰淇凌</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ice_Cream</span> <span class="keyword">extends</span> <span class="title class_">AddImp</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourMaterial</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;加冰淇凌-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 温度实现类：去冰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoIce</span> <span class="keyword">extends</span> <span class="title class_">IceImp</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourIce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;去冰-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甜度实现类：全糖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Full_Point</span> <span class="keyword">extends</span> <span class="title class_">SweetnessImp</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSweetness</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;全糖-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 假设需要：甜度实现类：大小</span></span><br><span class="line"><span class="comment">public class Super_Size extends SizeImp &#123;</span></span><br><span class="line"><span class="comment">    <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">    public void setSize() &#123;</span></span><br><span class="line"><span class="comment">        System.out.print(&quot;大杯-&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际产品实现类：咖啡奶盖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> <span class="keyword">extends</span> <span class="title class_">MilkTea</span> &#123;</span><br><span class="line">    <span class="comment">// 和上述实现类不同，继承MilkTea的类(具体产品)必须有实现类，用于设置上述三种奶茶的基础配置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Coffee</span><span class="params">()</span> &#123;</span><br><span class="line">        setMilkTeaImp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeMilkTea</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;咖啡奶盖&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>如何使用呢？来看下面的测试函数：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用单例模式确保只有一个MilkTeaImp存在</span></span><br><span class="line"><span class="comment">         * 在实例化MilkTeaImp的同时指定配方</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">MilkTeaSingleton</span> <span class="variable">milkTeaSingleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MilkTeaSingleton</span>(<span class="keyword">new</span> <span class="title class_">MilkTeaImp</span>(<span class="keyword">new</span> <span class="title class_">NoIce</span>(), <span class="keyword">new</span> <span class="title class_">Ice_Cream</span>(), <span class="keyword">new</span> <span class="title class_">Full_Point</span>()<span class="comment">/*, new Super_Size()*/</span>));</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Coffee</span>();</span><br><span class="line">        <span class="comment">// 使用模板方法制作奶茶</span></span><br><span class="line">        coffee.templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果: 去冰-加冰淇凌-全糖-咖啡奶盖 */</span></span><br><span class="line"><span class="comment">/* 可以修改代码并尝试更多组合 */</span></span><br></pre></td></tr></table></figure></div>
<p>可以发现，使用桥接器时，商户的额外需求<strong>仅需要14个类</strong>(3+4+4+3)，相对于144个类而言显然是更好的解决方案。此外，<strong>每次需要增加一个属性条目，桥接器只需新增一个实现类</strong>，而小明原有的设计中的类数量会成倍增加。</p>
<h3 id="summary">Summary</h3>
<ol type="1">
<li>桥接模式会增加系统的理解与设计难度，要求开发者针对抽象进行设计与编程</li>
<li>桥接模式要求正确识别出系统中两个/多个独立变化的维度，因此使用范围有一定局限性</li>
<li>桥接模式分离抽象与实现，提高了系统的扩展性</li>
<li>多继承可以实现类似桥接模式的效果，但是违背了单一职责原则，桥接模式是更好的解决方案</li>
</ol>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Decorator——装饰器</title>
    <url>/2022/05/05/Decorator/</url>
    <content><![CDATA[<h3 id="background">Background</h3>
<p>现实生活中有各种各样的装饰：穿衣服、刷油漆、给图画装裱相框、加Buff......</p>
<p><img src="/2022/05/05/Decorator/R.png" alt="未装饰前" style="zoom:80%;"></p>
<p><img src="/2022/05/05/Decorator/1000-1651737476679.png" alt="装饰后(至臻)" style="zoom:80%;"></p>
<p>回到编程上，我们通常可以采用<strong>继承</strong>来实现功能的扩展，但是如果这些需要扩展的功能很多时</p>
<ul>
<li>会产生很多子类，<strong>增加系统复杂性</strong></li>
<li>这些功能编译时就已经确定，是<strong>静态</strong>的</li>
</ul>
<p>这个时候应该怎么办？</p>
<h3 id="decorator">Decorator</h3>
<p><strong>动态(即插即用)</strong>地给一个<strong>对象(而非一个类，不影响其他对象)</strong>添加一些额外的职责</p>
<p>参与者协作者：</p>
<ol type="1">
<li><p><strong>Component</strong>：定义一个对象接口，可以给这些对象动态地添加职责。</p></li>
<li><p><strong>ConcreteComponent</strong>：定义一个对象，可以给这个对象添加一些职责</p></li>
<li><p><strong>Decorater</strong></p></li>
<li><p><strong>ConcreteDecorator</strong></p></li>
</ol>
<p><strong>适用情况举例</strong>：</p>
<ol type="1">
<li>不影响其他对象的情况下，<strong>动态</strong>地给单个对象添加职责</li>
<li><strong>处理可以撤销的职责</strong></li>
<li><strong>不能采用继承</strong>的方式进行扩充时</li>
</ol>
<blockquote>
<p>注意：装饰的顺序很重要！装饰器很容易出错，应谨慎适用！装饰器会增大系统复杂度！</p>
</blockquote>
<h3 id="example">Example</h3>
<p>下面举一些装饰器的例子：</p>
<p><img src="/2022/05/05/Decorator/image-20220505161616059.png" alt="image-20220505161616059" style="zoom:80%;"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象构件类: InputStream</span></span><br><span class="line"><span class="comment"> * 具体构件类: FileInputStream、ByteArrayInputStream</span></span><br><span class="line"><span class="comment"> * 抽象装饰类: FilterInputStream</span></span><br><span class="line"><span class="comment"> * 具体装饰类: BufferedInputStream、DataInputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">// 只针对对象reader1进行动态配置，添加读取文件职责</span></span><br><span class="line"><span class="type">Reader</span> <span class="variable">reader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineNumberReader</span>(<span class="keyword">new</span> <span class="title class_">BufferReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line"><span class="comment">// 只针对对象reader2进行动态配置，添加读取输入流职责</span></span><br><span class="line"><span class="type">Reader</span> <span class="variable">reader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineNumberReader</span>(<span class="keyword">new</span> <span class="title class_">BufferReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(Socket.getInputStream())));</span><br></pre></td></tr></table></figure></div>
<h3 id="extension">Extension</h3>
<p>装饰模式分为<strong>透明</strong>和<strong>半透明</strong>两种，大部分情况下都是采用半透明方式，半透明的装饰模式介于装饰模式和适配器模式之间。</p>
<h5 id="一透明装饰模式">一、透明装饰模式</h5>
<p>透明装饰模式就是<strong>纯粹为了装饰</strong>，而忽视增强性能的需要。实例代码如下：</p>
<blockquote>
<p><a href="https://github.com/relink2021/DesignPatternHomework/tree/master/src/Homework10">完整代码</a></p>
</blockquote>
<ul>
<li>还是以奶茶为例，定义抽象构件：奶茶</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 抽象奶茶接口，需要定义名称和价格 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MilkTea</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPrice</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>下面是两个具体构件：珍珠奶茶和板栗奶茶</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 珍珠奶茶 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PearlMilkTea</span> <span class="keyword">implements</span> <span class="title class_">MilkTea</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;珍珠奶茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 板栗奶茶 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChestnutMilkTea</span> <span class="keyword">implements</span> <span class="title class_">MilkTea</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;板栗奶茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>奶茶有各种风味，定义抽象装饰类Taste：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Taste</span> <span class="keyword">implements</span> <span class="title class_">MilkTea</span> &#123;</span><br><span class="line">    MilkTea milkTea;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Taste</span><span class="params">(MilkTea milkTea)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.milkTea = milkTea;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> milkTea.getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> milkTea.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>下面是奶茶具体的口味，具体装饰类：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 加冰块 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IceTaste</span> <span class="keyword">extends</span> <span class="title class_">Taste</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;加冰&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IceTaste</span><span class="params">(MilkTea milkTea)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(milkTea);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 添加属性 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getName() + <span class="string">&quot; &quot;</span> + description;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 加冰多加3块 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getPrice() + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加冰淇凌 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ice_Cream</span> <span class="keyword">extends</span> <span class="title class_">Taste</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;加冰淇凌&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Ice_Cream</span><span class="params">(MilkTea milkTea)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(milkTea);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 添加属性 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getName() + <span class="string">&quot; &quot;</span> + description;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 额外付5元 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getPrice() + <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>测试装饰器的功能：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 买了一杯珍珠奶茶，加冰淇凌</span></span><br><span class="line">        <span class="type">MilkTea</span> <span class="variable">pearlMilkTea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PearlMilkTea</span>();</span><br><span class="line">        pearlMilkTea = <span class="keyword">new</span> <span class="title class_">Ice_Cream</span>(pearlMilkTea);</span><br><span class="line">        System.out.print(pearlMilkTea.getName() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(pearlMilkTea.getPrice() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">        <span class="comment">// 买了一杯板栗奶茶，加冰块</span></span><br><span class="line">        <span class="type">MilkTea</span> <span class="variable">chestnutMilkTea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChestnutMilkTea</span>();</span><br><span class="line">        chestnutMilkTea = <span class="keyword">new</span> <span class="title class_">IceTaste</span>(chestnutMilkTea);</span><br><span class="line">        System.out.print(chestnutMilkTea.getName() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(chestnutMilkTea.getPrice() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行结果为：</span></span><br><span class="line"><span class="comment"> * 珍珠奶茶 加冰淇凌 13元</span></span><br><span class="line"><span class="comment"> * 板栗奶茶 加冰 16元</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div>
<p>透明装饰模式对特定对象进行装饰，对其添加特定职责(Taste为奶茶添加了风味，由奶茶负责展示风味)</p>
<h5 id="二半透明装饰模式">二、半透明装饰模式</h5>
<p>实际应用中大部分都是采取半透明的装饰方式，半透明装饰不止于给特定对象添加职责，还允许装饰模式改变方法，增加新的接口。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 半透明装饰: 改变接口，增加新的方法</span></span><br><span class="line"><span class="comment"> * 客户端可以生命具体装饰类，并调用具体装饰类中的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IceTaste</span> <span class="keyword">extends</span> <span class="title class_">Taste</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">iceEffect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;奶茶很冰&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ice_Cream</span> <span class="keyword">extends</span> <span class="title class_">Taste</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">ice_Cream_Effect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;冰淇凌很甜&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/* 买了一杯珍珠奶茶，加冰淇凌 */</span></span><br><span class="line">        <span class="type">MilkTea</span> <span class="variable">pearlMilkTea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PearlMilkTea</span>();</span><br><span class="line">        <span class="comment">/* 实例化Ice_Cream并使用方法 */</span></span><br><span class="line">        <span class="type">Ice_Cream</span> <span class="variable">ice_cream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ice_Cream</span>(pearlMilkTea);</span><br><span class="line">        System.out.println(ice_cream.ice_Cream_Effect());</span><br><span class="line">		<span class="comment">/* 实例化IceTaste并使用方法 */</span></span><br><span class="line">        <span class="type">IceTaste</span> <span class="variable">iceTaste</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IceTaste</span>(pearlMilkTea);</span><br><span class="line">        System.out.println(iceTaste.iceEffect());  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="summary">Summary</h3>
<ol type="1">
<li>装饰器模式的目标是对象而非类，不同对象经过装饰器装饰后可能有完全不同的职责。</li>
<li>装饰器有透明装饰和半透明装饰两种，区别在于半透明装饰除了装饰本身外，还允许具体装饰类扩展方法，强化系统功能。</li>
<li>装饰器存在多层嵌套的情况，此时装饰的顺序不能出错，需要小心谨慎。</li>
</ol>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/04/29/Design%20Patterns/</url>
    <content><![CDATA[<blockquote>
<h4 id="singleton单例模式">Singleton：单例模式</h4>
<p>确保类自身(类自己实现)<strong>只有一个实例</strong>，并<strong>提供</strong>它的<strong>全局访问点</strong></p>
<p>如何保证类只有一个实例？
<strong>使用类本身来负责，而不是用户负责</strong></p>
<p>应用：注册表、ID生成器、身份证、频繁访问数据库和文件对象、连接池、配置对象</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 静态私有成员变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"><span class="comment">// 2. 构造函数设置成private防止类外调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">	singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 共有的动态工厂方法</span></span><br><span class="line"><span class="comment">// 3.1 Eager Singleton: 孤子类在自己被加载时就实例化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singelton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.2 Lazy Singleton: 需要使用时再实例化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singelton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(instance == <span class="literal">null</span>)</span><br><span class="line">  	instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="type">Singleton</span> <span class="variable">obj</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lazy Singleton的双加锁机制，防止并发错误</span></span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">	lock(syncRoot); <span class="comment">// 先加锁</span></span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">  		instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重加锁的单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLockSingleton</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.指向自身实例的私有静态引用</span></span><br><span class="line"><span class="comment">     * volatile: 被volatile修饰的变量不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，禁止指令重排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">DoubleLockSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.私有的构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DoubleLockSingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.以自身实例为返回值的静态的共有方法</span></span><br><span class="line"><span class="comment">     * synchronized: 同步锁，保证同步区内的操作具有原子性、可见性、有序性</span></span><br><span class="line"><span class="comment">     * 原子性: 一个操作或多个操作，要么全部执行，要么全部不执行</span></span><br><span class="line"><span class="comment">     * 可见性: 多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的</span></span><br><span class="line"><span class="comment">     * 有序性: 有序性值程序执行的顺序按照代码先后执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DoubleLockSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 开启同步区</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleLockSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">DoubleLockSingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有静态内部类，避免多线程同步问题，还能反序列化创建新的对象</span></span><br><span class="line"><span class="comment"> * 1. 不提供构造函数杜绝用户产生该类实例</span></span><br><span class="line"><span class="comment"> * 2. 全部实例都是public static final，不允许变动却可以让用户使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="comment">// 使用final关键字保证只能实例化一次</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  	<span class="comment">// 通过调用内部类的getInstance方法保证单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式的变形：对象数量有限的多例模式</span></span><br><span class="line"><span class="comment"> * 核心思想：</span></span><br><span class="line"><span class="comment"> * 1.构造器私有化，外部不能随意new该对象</span></span><br><span class="line"><span class="comment"> * 2.对外提供获得修改对象的方法</span></span><br><span class="line"><span class="comment"> * 3.使用一个类变量记录允许的最大对象数量</span></span><br><span class="line"><span class="comment"> * 4.使用一个类变量记录当前对象的序号</span></span><br><span class="line"><span class="comment"> * 5.使用一个list记录所有产生的对象，每次使用时，都从list中获取对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LimitMultigrainMode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxNumsOfObject</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;LimitMultigrainMode&gt; limitMultigrainModeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;LimitMultigrainMode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">curNumsOfObject</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 事先实例化出maxNumsOfObject个对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxNumsOfObject; i++) &#123;</span><br><span class="line">            limitMultigrainModeList.add(<span class="keyword">new</span> <span class="title class_">LimitMultigrainMode</span>(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;个实例&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LimitMultigrainMode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LimitMultigrainMode</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        nameList.add(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LimitMultigrainMode <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 随机获取1~maxNumsOfObject个实例中的随机一个</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        curNumsOfObject = random.nextInt(maxNumsOfObject);</span><br><span class="line">        <span class="keyword">return</span> limitMultigrainModeList.get(curNumsOfObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(nameList.get(curNumsOfObject));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>三个要点：</p>
<ol type="1">
<li>某个类只能有一个实例</li>
<li>它必须自行创建这个实例</li>
<li>它必须自行向整个系统提供这个实例</li>
</ol>
<p>优点：</p>
<ol type="1">
<li>提供对<strong>唯一</strong>实例的<strong>受控</strong>访问</li>
<li>节约系统资源</li>
<li>允许<strong>可变数目</strong>的实例</li>
</ol>
<p>缺点：</p>
<ol type="1">
<li><strong>没有抽象层</strong>，扩展性差</li>
<li><strong>类职责太重</strong>，既充当工厂又充当产品角色</li>
<li><strong>滥用单例的负面问题</strong>，如共享连接池对象的程序过多而出现连接池溢出</li>
<li>多个类加载器可能导致单例模式失效</li>
</ol>
</blockquote>
<hr>
<blockquote>
<h4 id="adapter适配器模式">Adapter：适配器模式</h4>
<p>不能复用的原因可能仅仅是因为接口不匹配</p>
<p>适配器将现有的接口转化为客户类期望的接口，保证对现有类的重用</p>
<p><img src="/2022/04/29/Design%20Patterns/image-20220412111148990.png" alt="image-20220412111148990" style="zoom:80%;"></p>
<p>JDBC：适配器软件，提供Java语言程序和数据库的连接服务</p>
<p>客户类并不直接调用适配器类</p>
<p>应用：系统需要使用现有类，但类的接口不符合系统的需要，第三方组件，但组件的接口不一致(远程调用)</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的适配器模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">     		specificRequest();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的适配器模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"> 	<span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">     		<span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">     		adaptee.specificRequest();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 双向适配器</span></span><br><span class="line"><span class="comment"> * 1.编写需要双向适配的两个类接口</span></span><br><span class="line"><span class="comment"> * 2.编写两个类接口的实现类</span></span><br><span class="line"><span class="comment"> * 3.编写双向适配器，在适配器中重写接口的实现部分方法(需要相互适配的方法)</span></span><br><span class="line"><span class="comment"> * 4.使用适配器的构造函数实例化对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下有两个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catLooks</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dogLooks</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dogBark</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下有两个接口的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ICatImpl</span> <span class="keyword">implements</span> <span class="title class_">ICat</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catLooks</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我像一只猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我能抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDogImpl</span> <span class="keyword">implements</span> <span class="title class_">IDog</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dogLooks</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我像一条狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dogBark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会犬吠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 双向适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">implements</span> <span class="title class_">ICat</span>, IDog&#123;</span><br><span class="line">    <span class="type">ICat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">IDog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 两个接口的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(ICat cat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(IDog dog)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catLooks</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一只猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 猫学会犬吠</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        dog.dogBark();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dogLooks</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一条狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 狗学会抓老鼠</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dogBark</span><span class="params">()</span> &#123;</span><br><span class="line">        cat.catchMouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 把狗适配为猫</span></span><br><span class="line">        <span class="type">ICat</span> <span class="variable">fakeCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>(<span class="keyword">new</span> <span class="title class_">IDogImpl</span>());</span><br><span class="line">        fakeCat.catLooks();</span><br><span class="line">        fakeCat.catchMouse();</span><br><span class="line">        <span class="comment">// 把猫适配为狗</span></span><br><span class="line">        <span class="type">IDog</span> <span class="variable">fakeDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>(<span class="keyword">new</span> <span class="title class_">ICatImpl</span>());</span><br><span class="line">        fakeDog.dogLooks();</span><br><span class="line">        fakeDog.dogBark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>优点：</p>
<ol type="1">
<li>将目标类和适配器类<strong>解耦合</strong>，<strong>无需修改原有代码</strong></li>
<li>将具体的实现封装在适配器类中，提高了适配器的复用性</li>
<li><strong>灵活性和扩展性都非常好</strong>，使用配置文件可以方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，<strong>符合开闭原则</strong></li>
</ol>
<p>缺点：</p>
<ol type="1">
<li>对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配器类</li>
</ol>
</blockquote>
<hr>
<blockquote>
<h4 id="template-method模板模式">Template Method：模板模式</h4>
<p>不改变算法结构的前提下重定义某些特定步骤<strong>（本质：控制子类的扩展）</strong></p>
<p><span class="math inline">\(Template Method = \sum (Primitive
Methods)\)</span></p>
<p>模板：确保父类控制处理流程的逻辑顺序，需要保证<strong>模板的严肃性</strong>(final)</p>
<p>应用：框架设计</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight /scss"><table><tr><td class="code"><pre><span class="line">AbstractClass &#123;</span><br><span class="line">	<span class="built_in">method1</span>()</span><br><span class="line">	<span class="built_in">method2</span>()</span><br><span class="line">	<span class="built_in">method3</span>()</span><br><span class="line">	<span class="built_in">templateMethod</span>() <span class="comment">// 规定method1-3的处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="/2022/04/29/Design%20Patterns/image-20220419103112374.png" alt="image-20220419103112374" style="zoom:80%;"></p>
<p><strong>好莱坞原则</strong>：子类不显式调用父类的方法，而是通过覆盖父类的方法实现业务逻辑，父类控制对子类的调用</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractDisplay</span> &#123;</span><br><span class="line">   <span class="comment">// 三个抽象方法，子类可重定义</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>; </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">// 模板方法，规定执行顺序，必须用final修饰</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">       open();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           print();</span><br><span class="line">       &#125;</span><br><span class="line">       close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>钩子方法(Hook
Method)</strong>：实现子类对父类行为的反向控制</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">template</span><span class="params">()</span> &#123;</span><br><span class="line">	open();</span><br><span class="line">    display();</span><br><span class="line">       <span class="keyword">if</span>(isPrint()) &#123;</span><br><span class="line">       	print();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 钩子方法，子类可重写，用于控制print()方法是否实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPrint</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<p>优点：形式化定义算法，子类实现细节，是一种<strong>代码复用</strong>技术，构造一种<strong>反向控制</strong>结构，符合<strong>开闭原则</strong></p>
<p>缺点：每个不同实现都要定义一个子类，导致类个数增加，系统庞大，但符合<strong>单一职责原则</strong>，<strong>增强内聚性</strong></p>
<p>启发：逻辑可共享(父类和子类共享逻辑)，向上转型(子类视同父类)，父类和子类的协调，好莱坞原则</p>
</blockquote>
<hr>
<blockquote>
<h4 id="inversion-of-controlioc控制反转">Inversion of
Control(Ioc)：控制反转</h4>
<p><strong>Ioc是一种设计原则而非设计模式</strong>，设计模式和Ioc的关系：</p>
<p><img src="/2022/04/29/Design%20Patterns/image-20220420093403816.png" alt="image-20220420093403816" style="zoom:80%;"></p>
<p>用于在面向对象设计中反转不同类型的控件实现<strong>松散耦合</strong>的设计(为什么需要松散耦合的设计?)</p>
<ul>
<li>一个类的变动不会迫使另一个类的变动，因此增强了整个应用的可维护性和可扩展性</li>
</ul>
<p>control是指除了其主要职责之外的任何其他职责，包括：</p>
<ul>
<li>对应用程序流程的控制</li>
<li>对象创建或依赖对象创建和绑定流程的控制</li>
</ul>
<p>举例：自己开车到工作单位 <span class="math inline">\(\rightarrow\)</span> 雇了一个出租车司机到工作单位
(从自己到出租车司机的控制反转)</p>
<p><img src="/2022/04/29/Design%20Patterns/image-20220420085422288.png" alt="image-20220420085422288" style="zoom:80%;"></p>
<p><strong>程序流程的控制</strong>：</p>
<p>举例：使用Main函数控制程序流程 <span class="math inline">\(\rightarrow\)</span> 使用GUI控制程序流程</p>
<p><strong>控制从属对象的创建：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非Ioc写法</span></span><br><span class="line"><span class="comment"> * A调用b的someMethod方法实现Task1方法，A不能脱离B完成这个任务，故A依赖于B</span></span><br><span class="line"><span class="comment"> * 本质：A控制了B对象的创建和生命周期</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span> <span class="params">()</span> &#123;</span><br><span class="line">        b = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Task1</span><span class="params">()</span> &#123;</span><br><span class="line">        b.someMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// doing something..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ioc写法</span></span><br><span class="line"><span class="comment"> * 类A使用Factory来获得一个B的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        b = Factory.getObjectOfB();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Task1</span><span class="params">()</span> &#123;</span><br><span class="line">        b.someMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用工厂类来创建B实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> B <span class="title function_">GetObjectOfB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>以n层架构为例：</p>
<p><img src="/2022/04/29/Design%20Patterns/image-20220420092015357.png" alt="image-20220420092015357" style="zoom:80%;"></p>
<p>UI通过Service获取或存储数据，Service层依赖BusinessLogic对数据的存取规则，BusinessLogic依赖数据库</p>
<p>现在关注BusinessLogic和DataAccess：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此时DAO依赖于Mapper</span></span><br><span class="line"><span class="comment"> * 造成了CustomerBusinessLogic和DataAccess两个类紧耦合</span></span><br><span class="line"><span class="comment"> * 问题1：此时如果需要改变DataAccess(增加|删除方法)，CustomerBusinessLogic也需要随之改变</span></span><br><span class="line"><span class="comment"> * 问题2：如果用户数据来自于不同的数据库，则后续需要创建不同的Mapper类，DAO也需要随之改变</span></span><br><span class="line"><span class="comment"> * 问题3：如果需要对DataAccess重命名，则需要找到所有应用DataAccess的位置进行修改</span></span><br><span class="line"><span class="comment"> * 问题4：CustomerBusinessLogic依赖DataAccess创建，那么就无法进行独立测试(TDD)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerBusinessLogic</span> &#123;</span><br><span class="line">    DataAccess dataAccess;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerBusinessLogic</span><span class="params">()</span> &#123;</span><br><span class="line">        dataAccess = <span class="keyword">new</span> <span class="title class_">DataAccess</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataAccess.getCustomerName(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataAccess</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataAccess</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dummy Customer Name&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Ioc解决该问题</span></span><br><span class="line"><span class="comment">// 1. 创建一个返回DataAccess实例的Factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataAccessFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DataAccess <span class="title function_">getDataAccessObj</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataAccess</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.使用DataAccessFactory在CustomerBusiness创建DataAccess实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerBusinessLogic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerBusinessLogic</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">DataAccess</span> <span class="variable">dataAccess</span> <span class="operator">=</span> DataAccessFactory.getDataAccessObj();</span><br><span class="line">        <span class="keyword">return</span> dataAccess.getCustomerName(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="dependency-inversion-principledip依赖倒置原则">Dependency
Inversion Principle(DIP)：依赖倒置原则</h4>
<p>DIP是SOLID面向对象原则之一，定义为：</p>
<ul>
<li>高级模块不应该依赖低级模块，两者都应该依赖于抽象</li>
<li>抽象不应该依赖于具体实现，具体实现应该依赖于抽象</li>
</ul>
<p>对于上述实现了Ioc的代码，仍然存在一些问题：</p>
<ul>
<li>CustomerBusinessLogic类仍然聚合了DataAccess，仍然为紧耦合</li>
</ul>
<p>下面使用DIP得到更为松散耦合的结构：</p>
<ul>
<li>确定哪些是高级模块，哪些是低级模块，在例子中CustomerBusinessLogic依赖于DataAccess所以是高级模块，DataAccess则是低级模块，两者都应该依赖于抽象</li>
</ul>
<p>什么是抽象？不具体的就是抽象</p>
<ul>
<li>对于CustomerBusinessLogic和DataAccess都是具体类，我们<strong>可以创建它们的实例</strong>，<strong>但是我们不能创建抽象类的实例</strong></li>
<li>两者都依赖于抽象，即<strong>都依赖于接口或抽象类</strong></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象：用户数据存取接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICustomerDataAccess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低级模块：在CustomerDataAccess类中实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerDataAccess</span> <span class="keyword">implements</span> <span class="title class_">ICustomerDataAccess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerDataAccess</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dummy Customer Name&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变工厂类，使其返回接口而非具体的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataAccessFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ICustomerDataAccess <span class="title function_">getCustomerDataAccessObj</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomerDataAccess</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高级模块：改变CustomerBusinessLogic，使其使用接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerBusinessLogic</span> &#123;</span><br><span class="line">    ICustomerDataAccess iCustomerDataAccess;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerBusinessLogic</span><span class="params">()</span> &#123;</span><br><span class="line">        iCustomerDataAccess = DataAccessFactory.getCustomerDataAccessObj();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iCustomerDataAccess.getCustomerName(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>DIP的优点：CustomerBusinessLogic和DataAccess愈发松散耦合(因为CustomerBusinessLogic不依赖于具体类而是抽象接口)</p>
<h4 id="dependency-injectiondi依赖注入">Dependency
Injection(DI)：依赖注入</h4>
<p>Ioc和DIP存在的问题：在CustomerBusinessLogic类中使用了工厂，此时如果有ICustomerDataAccess的其他实现方式，同样需要修改CustomerBusinessLogic的源代码，而DI能够解决这一问题。</p>
<p><strong>DI是一种设计模式</strong>，使得类之间完全松散耦合，将创建和绑定依赖的对象移除类外</p>
<p>DI中涉及三种类：</p>
<ol type="1">
<li>客户端类(Client Class)：依赖于服务端类的类</li>
<li>服务端类(Service Class) ：给客户端提供服务的类</li>
<li>注射器类(Injector Class)：将服务端类注入客户端类的类</li>
</ol>
<p><img src="/2022/04/29/Design%20Patterns/image-20220420103203215.png" alt="image-20220420103203215" style="zoom:80%;"></p>
<p>三个类的关系如上图，可以发现注射剂创建了一个服务类实例，并且将该类注入客户类，这将创建服务类实例的职责从客户端中分离开来。</p>
<p><strong>依赖注入的类型：</strong></p>
<ul>
<li>构造函数注入：注射器通过客户类的构造函数提供服务</li>
<li>属性注入：提供给客户类公共属性</li>
<li>方法注入：客户类实现一个接口，注射器通过这个接口提供服务</li>
</ul>
<p>举例：使用CustomerService作为注射器类</p>
<p><strong>构造函数注入</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注射器类，创建CustomerDataAccess并将其注入到CustomerBusinessLoic中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerService</span> &#123;</span><br><span class="line">    CustomerBusinessLoic customerBusinessLoic;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerService</span><span class="params">()</span> &#123;</span><br><span class="line">        customerBusinessLogic = <span class="keyword">new</span> <span class="title class_">CustomerBusinessLogic</span>(<span class="keyword">new</span> <span class="title class_">CustomerDataAccess</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> customerBusinessLogic.processCustomerData(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用该类现在必须注入一个ICustomerDataAccess对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerBusinessLogic</span> &#123;</span><br><span class="line">    ICustomerDataAccess dataAccess;</span><br><span class="line">	<span class="comment">// 包含了一个具有ICustomerDataAccess类型参数的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerBusinessLogic</span><span class="params">(ICustomerDataAccess custDataAccess)</span> &#123;</span><br><span class="line">        dataAccess = custDataAccess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerBusinessLogic</span><span class="params">()</span> &#123;</span><br><span class="line">        dataAccess = <span class="keyword">new</span> <span class="title class_">CustomerDataAccess</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">processCustomerData</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataAccess.getCustomerName(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICustomerDataAccess</span> &#123;</span><br><span class="line">    String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerDataAccess</span> <span class="keyword">implements</span> <span class="title class_">ICustomerDataAccess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerDataAccess</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">//get the customer name from the db in real application        </span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dummy Customer Name&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>属性注入</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerBusinessLogic</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerBusinessLogic</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DataAccess.getCustomerName(id);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 包含了公共属性DataAccess，可以在其中设置实现ICustomerDataAccess的实例</span></span><br><span class="line">    <span class="keyword">public</span> ICustomerDataAccess DataAccess &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerService</span> &#123;</span><br><span class="line">    CustomerBusinessLogic customerBusinessLogic;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerService</span><span class="params">()</span> &#123;</span><br><span class="line">        customerBusinessLogic = <span class="keyword">new</span> <span class="title class_">CustomerBusinessLogic</span>();</span><br><span class="line">        customerBusinessLogic.DataAccess = <span class="keyword">new</span> <span class="title class_">CustomerDataAccess</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> customerBusinessLogic.getCustomerName(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>方法注入</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDataAccessDependency</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setDependency</span><span class="params">(ICustomerDataAccess customerDataAccess)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerBusinessLogic</span> <span class="keyword">implements</span> <span class="title class_">IDataAccessDependency</span> &#123;</span><br><span class="line">    ICustomerDataAccess dataAccess;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerBusinessLogic</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataAccess.getCustomerName(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDependency</span><span class="params">(ICustomerDataAccess customerDataAccess)</span> &#123;</span><br><span class="line">        dataAccess = customerDataAccess;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerService</span> &#123;</span><br><span class="line">    CustomerBusinessLogic customerBusinessLogic;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerService</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        customerBusinessLogic = <span class="keyword">new</span> <span class="title class_">CustomerBusinessLogic</span>();</span><br><span class="line">        ((IDataAccessDependency)customerBusinessLogic).setDependency(<span class="keyword">new</span> <span class="title class_">CustomerDataAccess</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> customerBusinessLogic.getCustomerName(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<hr>
<blockquote>
<h4 id="iterator-pattern迭代器模式"><strong>Iterator
Pattern</strong>：迭代器模式</h4>
<p>变量i的功能抽象化，提供一种方法顺序访问一个聚合对象中的各个元素，而又<strong>不暴露该对象的内部表示</strong></p>
<p>应用：支持对聚合对象的多种遍历；对不同聚合结构提供统一接口；遍历聚合对象并不暴露内部结构</p>
</blockquote>
<hr>
<blockquote>
<h4 id="factory-method工厂方法模式">Factory Method：工厂方法模式</h4>
<p>定义一个<strong>创建对象的接口</strong>，<strong>让子类决定实例化哪个类</strong>，讲一个类的实例化延迟到子类</p>
<p>解决的问题：<strong>创建一个初始化过程较为复杂的对象，并对外隐藏这些细节</strong></p>
<ul>
<li>连接池中的对象，不是每次都创建新的，池大小的参数可以用额外的逻辑控制</li>
<li>希望隐藏对象真实的类型</li>
<li>创建对象需要很多参数，如xml或json</li>
<li>简化常规的创建过程</li>
<li>创建具有复杂依赖关系的对象(Ioc)</li>
<li>无法把握创建的时机</li>
<li>避免在构造函数中抛出异常</li>
</ul>
<p>应用：<strong>框架</strong>使用抽象类定义和维护对象之间的关系，这些对象的创建也通常由框架负责</p>
<ul>
<li>当一个类不知道它所创建的对象的类时</li>
<li>当一个类希望由它的子类来指定它所创建的对象时</li>
<li>可使用<strong>配置文件</strong>指定具体工厂类</li>
</ul>
<p>主要角色：</p>
<ul>
<li>Factory：抽象工厂</li>
<li>Product：抽象产品</li>
<li>ConcreteFactory：具体工厂</li>
<li>ConcreteProduct：具体产品</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>优点：隐藏具体类被实例化的细节，鲜明的<strong>多态</strong>属性，<strong>扩展性好</strong>，符合<strong>开闭原则</strong>。</p>
<p>缺点：每添加一个类，<strong>类的个数成对增加</strong>，会给系统带来一定的额外开销。</p>
<p>参考资料：</p>
<h4 id="工厂模式的本质是什么"><a href="https://www.zhihu.com/question/42975862/answer/1239305317">工厂模式的本质是什么</a></h4>
</blockquote>
<hr>
<blockquote>
<h4 id="prototype原型模式">Prototype：原型模式</h4>
<p>用<strong>原型实例</strong>指定创建对象的种类，并且通过<strong>拷贝</strong>这些原型创建新的对象，可以减少类的数目</p>
<ul>
<li>很多软件的Ctrl+C和Ctrl+V就是原型模式的应用</li>
<li>Java Object中的clone()</li>
</ul>
</blockquote>
<hr>
<blockquote>
<h4 id="builder创建者模式">Builder：创建者模式</h4>
<p>对于复杂的对象，用户只需要指定复杂<strong>对象的类型</strong>就能得到改对象</p>
<p><strong>复杂对象的组合过程外部化</strong>到一个称作创建者的对象里</p>
<p>核心思想：同样的过程，不同的构造</p>
<p>应用场景：</p>
<ul>
<li>构造过程允许构造的对象有不同的表示</li>
<li>创建复杂对象的算法独立于对象的组成部分</li>
</ul>
</blockquote>
<hr>
<blockquote>
<h4 id="abstract-factory抽象工厂模式">Abstract
Factory：抽象工厂模式</h4>
<p>产品族、产品等级结构</p>
</blockquote>
]]></content>
      <tags>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘模型——GBDT</title>
    <url>/2022/05/25/GBDT/</url>
    <content><![CDATA[<blockquote>
<p>参考资料：</p>
<p><a href="https://scikit-learn.org/stable/modules/ensemble.html?highlight=gbdt">scikit-learn.org</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/144855223">知乎文章：GBDT(梯度提升决策树)——来由、原理和python实现</a></p>
<p><a href="https://blog.csdn.net/zpalyq110/article/details/79527653">CSDN文章：GBDT算法原理以及实例理解</a></p>
</blockquote>
<h4 id="一什么是gbdt">一、什么是GBDT？</h4>
<p>GBDT的全称是Gradient Boosting Decision
Tree(梯度提升决策树)，GBDT是一种<strong>集成模型</strong>，采用的基础模型是<strong>CART回归树</strong>。</p>
<h4 id="二集成模型">二、集成模型</h4>
<h5 id="背景">2.1 背景</h5>
<p>几乎所有<strong>预测性质</strong>任务都可以抽象为基于已知数据<span class="math inline">\(x\)</span>预测未知数据<span class="math inline">\(y\)</span>，用函数形式表示，即 <span class="math display">\[y=f(x)\]</span></p>
<p>但是，显然没有模型可以做到分毫不差地预测，预测值和真实值总是存在差异，<span class="math display">\[y=f(x) + residual\]</span></p>
<p>其中<span class="math inline">\(residual\)</span>被称为残差，我们评价一个模型的预测能力，一般考虑残差的两个方面</p>
<ol type="1">
<li><strong>偏差</strong>，与真实值分布的偏差大小</li>
<li><strong>方差</strong>，体现模型预测能力的稳定性</li>
</ol>
<p>GBDT采用了多模型集成策略，针对残差进行拟合，进而将降低模型的偏差和方差。</p>
<h5 id="介绍">2.2 介绍</h5>
<p>集成学习(Ensemble
Model)是一种模型框架，将若干弱学习器按照一定的策略组合起来，共同完成一个任务，只要组合得当，就可以帮助集成模型降低预测的偏差或方差。</p>
<p>常见的集成策略有bagging、stacking和boosting，GBDT显然属于第三种。</p>
<h5 id="boosting模型">2.3 Boosting模型</h5>
<p>Boosting模型采用将基础模型串联组合的形式，这类模型的思想是：既然一个基础模型可以做出不完美的预测，那么我们可以使用更多基础模型，对“不完美的部分”进行完善。对于GBDT来说，它会用第K个CART拟合前K-1个CART留下的残差，从而不断缩小整个模型的误差。</p>
<blockquote>
<p>通俗理解：一个人有30岁，首先使用20岁拟合，发现有10岁的损失。这时候使用6岁拟合剩下的损失，发现差距还有4岁，第三轮用3岁拟合剩下的差距，损失就只剩下1岁了。</p>
<p>每一轮迭代，都将拟合的损失减少，经过若干轮迭代，剩余的损失越来越少。迭代结束后，就能得到一个较优的模型(也称为强学习器)，这就是GBDT原理的通俗理解。</p>
</blockquote>
<p><img src="/2022/05/25/GBDT/绘图1-1653476751454.png" alt="绘图1" style="zoom:80%;"></p>
<h5 id="cart树">2.4 CART树</h5>
<p>CART是Classification and Regression
Tree的缩写，特指一种以二叉树为逻辑结构的，用于完成线性回归任务的决策树(决策树详细介绍见决策树.md)。</p>
<p>CART回归树的思想是当事物的特征为<strong>连续变量</strong>时，使用一种新的策略，来选择用于分割样本的特征值。特征取值连续并允许重复使用，这一定会导致严重地过拟合，因此需要对CART回归树进行剪枝。</p>
<p>CART回归树是GBDT的基础，因为GBDT每次迭代要拟合的是<strong>梯度值</strong>，这是一个连续值，因此要使用回归树。</p>
<h4 id="三gbdt">三、GBDT</h4>
<p>sklearn中有GBDT工具包，提供分类和回归方法。</p>
<p><strong>GradientBoostingClassifier</strong>和
<strong>GradientBoostingRegressor</strong>是小样本数据集的首选，这两个估计器的两个重要超参数是<code>n_estimators</code>和<code>learning_rate</code>。</p>
<h5 id="分类gradientboostingclassifier">3.1
分类：GradientBoostingClassifier</h5>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该分类器支持二分类和多分类</span></span><br><span class="line"><span class="comment"># 以下是将具有100个决策树桩的梯度提升分类器拟合为CART</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line">GradientBoostingClassifier(n_estimators=<span class="number">100</span>, learning_rate=<span class="number">1.0</span>, max_depth=<span class="number">1</span>, random_state=<span class="number">0</span>).fit(X_train, y_train)</span><br></pre></td></tr></table></figure></div>
<p><strong>CART的数量</strong>由参数<code>n_estimators</code>控制，<strong>每棵树的大小</strong>由<code>max_depth</code>设置，<strong>叶节点的数量</strong>由<code>max_leaf_nodes</code>控制。<code>learning_rate</code>范围为(0.0,1.0]，通过收缩<strong>控制过拟合</strong>。</p>
<blockquote>
<p>注意：超过两个的分类需要引入参数n_classes，引入的树的数量等于n_classes
* n_estimators。</p>
<p>对于大数据，更推荐使用 HistGradientBoostingClassifier。</p>
</blockquote>
<h5 id="回归gradientboostingregressor">3.2
回归：GradientBoostingRegressor</h5>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回归的默认损失函数的平方误差 squared_error</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingRegressor</span><br><span class="line">est = GradientBoostingRegressor(n_estimators=<span class="number">100</span>, learning_rate=<span class="number">0.1</span>, max_depth=<span class="number">1</span>, random_state=<span class="number">0</span>, loss=<span class="string">&#x27;squared_error&#x27;</span>).fit(X_train, y_train)</span><br></pre></td></tr></table></figure></div>
<h4 id="四提升gbdt效果的办法">四、提升GBDT效果的办法</h4>
<h5 id="重采样">4.1 重采样</h5>
<p>将boosting和bagging相结合，每次迭代中，基础分类器都会根据<code>subsample</code>在可用训练数据中取一部分进行训练。子样本在没有替换的情况下抽取，典型值为<code>subsample=0.5</code></p>
<h5 id="验证方法">4.2 验证方法</h5>
<p>对于小样本，一般采用交叉验证法</p>
]]></content>
      <tags>
        <tag>数据挖掘</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>JUnit</title>
    <url>/2022/05/08/JUnit/</url>
    <content><![CDATA[<h3 id="junit介绍">JUnit介绍</h3>
<p>JUnit一种开源测试框架，提供了许多断言方法，允许设置测试的规则，如</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">assertEquals()  <span class="comment">// 结果等于...</span></span><br><span class="line">assertNull()    <span class="comment">// 结果为Null</span></span><br><span class="line">assertNotSame() <span class="comment">// 结果不同于...</span></span><br><span class="line">assertTrue()    <span class="comment">// 结果为True</span></span><br></pre></td></tr></table></figure></div>
<p>一个测试用例包含多个断言，当测试用例运行后，JUnit运行器会报告哪些断言没有通过</p>
<h3 id="junit框架">JUnit框架</h3>
<p><img src="/2022/05/08/JUnit/image-20220508182055793.png" alt="image-20220508182055793" style="zoom:80%;"></p>
<p><strong>Test</strong>：接口，拥有抽象方法run()，用于<strong>运行测试用例</strong></p>
<p><strong>TestCase</strong>：测试用例类，业务类只需要继承该类，并编写test方法，在方法中通过assert方法就能够自定义测试规则</p>
<blockquote>
<p>测试方法为什么必须以test为前缀，且必须是public void的？</p>
<p>答：因为运行器通过<strong>反射机制</strong>查找测试类。</p>
</blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> junit.framework.TestCase;</span><br><span class="line"><span class="comment">// 继承TestCase即可编写测试方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">TestCase</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.setUp();</span><br><span class="line">        <span class="comment">// 初始化测试固件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 带有textXXXX字样的就是测试方法，可以单独运行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod1</span><span class="params">()</span> &#123;</span><br><span class="line">        assertEquals(...); <span class="comment">// 通过断言进行测试规则的定义</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.tearDown();</span><br><span class="line">        <span class="comment">// 销毁测试固件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>TestSuite</strong>：测试套件，可以将多个测试用例类捆绑在一起运行，也可以捆绑另一个测试套件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> junit.framework.Test;</span><br><span class="line"><span class="keyword">import</span> junit.framework.TestCase;</span><br><span class="line"><span class="keyword">import</span> junit.framework.TestSuite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTestSuite</span> <span class="keyword">extends</span> <span class="title class_">TestCase</span> &#123;</span><br><span class="line">    <span class="comment">// 测试套件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title function_">suite</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TestSuite</span> <span class="variable">suite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestSuite</span>();</span><br><span class="line">        <span class="comment">// 捆绑ATest和BTest测试类</span></span><br><span class="line">        suite.addTestSuite(ATest.class);</span><br><span class="line">        suite.addTestSuite(BTest.class);</span><br><span class="line">        <span class="keyword">return</span> suite;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="相关定义">相关定义</h3>
<h5 id="测试固件">测试固件</h5>
<p>在一个测试用例中必然需要调用被<strong>测试的类对象</strong>，而这组对象就称为测试固件，相当于测试用例的工作对象。</p>
<h5 id="测试用例">测试用例</h5>
<p>在测试类中，每一个testXXX()方法都代表一个测试用例</p>
<h5 id="测试套件">测试套件</h5>
<p>多个测试用例组装起来就成为了一个测试套件，可以批量运行测试用例</p>
<h5 id="测试运行器">测试运行器</h5>
<p>JUnit提供3个标准的测试运行器：</p>
<ul>
<li>junit.textui.TestRunner：文本测试运行器</li>
<li>junit.awtui.TestRunner：使用AWT组件</li>
<li>junit.swingui.TestRunner：使用Swing组件</li>
</ul>
]]></content>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>LoadRunner的基本使用</title>
    <url>/2022/05/06/LoadRunner/</url>
    <content><![CDATA[<h3 id="性能测试">性能测试</h3>
<hr>
<h4 id="基本概念">基本概念</h4>
<h5 id="什么是性能测试">什么是性能测试？</h5>
<p>性能测试是针对软件的性能进行的测试，即测试软件运行时的<strong>时间和资源占用率</strong></p>
<h5 id="如何进行性能测试">如何进行性能测试？</h5>
<p>通过自动化测试工具模拟用户来测试系统<strong>能否承载用户多并发，系统是否稳定，响应时间是否达到期望。</strong></p>
<h5 id="性能测试的目的">性能测试的目的？</h5>
<ol type="1">
<li>评估当前系统的能力，通过测试得到系统整体的评估。</li>
<li>寻找性能瓶颈，优化性能</li>
<li>预测未来性能</li>
</ol>
<h5 id="性能测试的注意事项">性能测试的注意事项？</h5>
<ol type="1">
<li>性能测试需要独立的测试环境(网络和硬件环境)<br>
</li>
<li>需要定义测试目标(成本高)</li>
<li>尽早执行</li>
</ol>
<hr>
<h4 id="性能测试的分类">性能测试的分类</h4>
<h5 id="基准测试">基准测试</h5>
<p>在一定的测试环境下，模拟<strong>单用户</strong>访问请求一种或多种业务为，<strong>产出基准性能参数</strong>，为多用户并发测试和综合测试<strong>提供参考依据</strong></p>
<p><strong>并发测试</strong></p>
<p>模拟多<strong>用户同时访问</strong>同一应用、模块或数据，观察是否存在问题</p>
<p><strong>负载测试</strong></p>
<p>对被测系统<strong>不断加压</strong>，直到超过预定指标或资源达到饱和状态不能加压为止</p>
<p><strong>压力测试</strong></p>
<p>系统已经<strong>达到一定饱和程度(CPU、磁盘)的情况下，系统能够处理业务的能力</strong></p>
<p><strong>稳定性测试</strong></p>
<p>给系统加载<strong>一定业务压力</strong>的情况下，<strong>使系统运行一周</strong>，检测系统是否稳定</p>
<h5 id="配置测试">配置测试</h5>
<p>通过<strong>软硬件配置</strong>调整，了解不同配置对系统性能影响的程度，从而<strong>找到最优配置</strong></p>
<hr>
<h4 id="性能测试指标">性能测试指标</h4>
<h5 id="系统指标1响应时间">系统指标1：响应时间</h5>
<p>从用户<strong>发送一个请求</strong>到用户<strong>接收到服务器返回的响应数据</strong>的时间
= 网络传输时间 + 应用处理时间</p>
<h5 id="系统指标2并发数">系统指标2：并发数</h5>
<ol type="1">
<li>并发用户数：某个物理<strong>时刻</strong>同时向系统<strong>提交请求的用户数</strong></li>
<li>在线用户数：某段时间<strong>访问系统的用户数</strong>，不一定向系统提交请求</li>
<li>系统用户数：系统注册的<strong>总用户</strong></li>
</ol>
<h5 id="系统指标3tps每秒事务数">系统指标3：TPS(每秒事务数)</h5>
<p><strong>单位时间</strong>内系统处理客户端请求的事务次数</p>
<p><strong>计算方法：</strong>TPS = 并发数/平均响应时间</p>
<p><img src="/2022/05/06/LoadRunner/Screenshot_2022-05-06-09-19-57-07_149003a2d400f6a-1651800152876.jpg" alt="Screenshot_2022-05-06-09-19-57-07_149003a2d400f6a" style="zoom: 50%;"></p>
<h5 id="资源指标资源利用率">资源指标：资源利用率</h5>
<p>不同系统资源的使用程度，通常用<strong>占用的最大百分比</strong>衡量</p>
<p><strong>服务器资源指标</strong>：</p>
<ol type="1">
<li>CPU使用率(85%)</li>
<li>内存利用率(85%)</li>
<li>磁盘I/O</li>
<li>网络带宽(100Mb/8 = 12.5MB)</li>
</ol>
<hr>
<h3 id="性能测试流程">性能测试流程</h3>
<h5 id="宏观流程">宏观流程</h5>
<p>需求分析 <span class="math inline">\(\rightarrow\)</span>
编写测试计划和方案 <span class="math inline">\(\rightarrow\)</span>
测试执行 <span class="math inline">\(\rightarrow\)</span> 结果分析</p>
<h5 id="需求分析">需求分析</h5>
<p>需求分析是性能测试的基础，直接影响性能测试的结果，需要明确：</p>
<ol type="1">
<li><strong>被测系统</strong>：系统架构、开发语言、运行环境</li>
<li><strong>测试内容</strong>：需要测试的业务</li>
<li><strong>测试策略</strong>：基准测试、压力测试、负载测试、稳定性测试等</li>
<li><strong>测试指标</strong>：并发用户数、响应时间、CPU使用率等等</li>
</ol>
<blockquote>
<p>例子：某电商要求每天完成交易额2亿元</p>
<p>根据28定律，80%的用户请求集中在20%的热点时间段，以每单300元计算</p>
<p>每日交易数 = 200000000/300 = 666666.66666</p>
<p>每小时交易数 = 666666 * 0.8 / (24 * 0.2) = 111111</p>
<p><strong>TPS = 111111 / 3600 = 30.86</strong></p>
</blockquote>
<h5 id="测试计划和测试方案">测试计划和测试方案</h5>
<p>测试计划需要明确以下几点：</p>
<ol type="1">
<li><p><strong>测试目标</strong>：某些具体业务(登录、支付等)</p></li>
<li><p><strong>人力资源</strong>：明确性能测试时间、计划测试的参与人数</p></li>
<li><p><strong>时间进度</strong>：制定时间进度表，如下图</p>
<table>
<thead>
<tr class="header">
<th>性能测试</th>
<th>工作日</th>
<th>开始时间</th>
<th>结束时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>测试用例设计</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>测试环境搭建</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>测试数据准备</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>脚本开发及执行</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>测试结果分析</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table></li>
<li><p><strong>风险评估</strong>：列出可能存在的风险(本地和实际机器测试环境的区别等)</p></li>
</ol>
<p>测试方案和测试计划存在一些区别：</p>
<ol type="1">
<li><strong>测试环境</strong>：架构设计、软硬件配置(服务器、数据库)</li>
<li><strong>测试工具</strong>：性能测试工具(LoadRunner、Jmeter等)、监控工具(Linux的nmon等)</li>
<li><strong>测试策略</strong>：单一场景(登录/下单)、混合场景(登录后查看商品然后下单)、稳定性测试</li>
</ol>
<blockquote>
<p>测试环境应尽可能与生产环境一致！</p>
</blockquote>
<h5 id="测试用例设计及执行">测试用例设计及执行</h5>
<p>测试<strong>性能点</strong>：登录、注册</p>
<p><strong>用例编写</strong></p>
<ol type="1">
<li><p>预期性能指标用例如下：</p>
<table>
<thead>
<tr class="header">
<th>用例编号</th>
<th>用例目的</th>
<th>测试数据</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>登录-001</td>
<td>测试100个虚拟用户并发时，系统登录的响应时间</td>
<td>3000</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>操作步骤（该表格可以省略）</th>
<th>期望的性能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td>点击Login登录</td>
<td>&lt;1s</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table></li>
<li><p><strong>单业务并发性能</strong></p></li>
<li><p><strong>混合场景并发性能</strong></p></li>
</ol>
<p><strong>用例执行</strong></p>
<ol type="1">
<li><strong>脚本编写</strong>：根据测试用例编写对应脚本</li>
<li><strong>场景监控设计</strong>：将编写好的脚本设计执行(执行次数、执行时间)</li>
<li><strong>生成测试报告</strong>：表格、图标、性能评估</li>
</ol>
<hr>
<h3 id="loadrunner">LoadRunner</h3>
<p>LoadRunner是一种功能强大的负载测试工具，通过模拟大量的虚拟测试用户对系统进行性能测试</p>
<blockquote>
<p>安装教程：<a href="https://www.cnblogs.com/echo-hui/p/9969475.html">LoadRunner11的安装、破解和汉化</a></p>
<p>LoadRunner12支持IE9+浏览器，但是没有好的破解方法，LoadRunner11仅支持IE8，建议在Win7使用</p>
</blockquote>
<h4 id="loadrunner的基本组成重点">LoadRunner的基本组成(重点)</h4>
<p>LoadRunner由4部分组成，分别是Virtual user generator、Controller、Load
Generator和Analysis</p>
<ul>
<li>用户脚本(Virtual user generator)
<ul>
<li>简称VuGen</li>
<li>录制与编写脚本的地方，通过录制或编写脚本模拟用户的行为，同时打印出日志信息方便调试</li>
<li>VuGen也是一个IDE，在这里完成脚本开发并调试通过后就可以放到Controller中创建场景</li>
</ul></li>
<li>控制台(Controller)
<ul>
<li>是性能测试场景设计以及监控的地方，用于设计场景</li>
<li>Controller本身无法形成负载，它只是一个设计工具</li>
</ul></li>
<li>负载生成器(Load Generator)
<ul>
<li>负责将VuGen脚本复制成大量虚拟用户对系统生成负载</li>
<li>生成的负载一般数量较大，通过一台Controller调用多台Generator</li>
</ul></li>
<li>结果分析器(Analysis)
<ul>
<li>收集测试数据后生成图标报告，便于对相关数据进行整理分析</li>
</ul></li>
</ul>
<blockquote>
<p>注意：在LoadRunner中，Controller和Load
Generator都在放在Controller中，通过Controller调用Load Generator</p>
</blockquote>
<h5 id="loadrunner自带的测试环境">LoadRunner自带的测试环境</h5>
<p>启动程序：HP LoadRunner <span class="math inline">\(\rightarrow\)</span> Start Web Server</p>
<p>登录前端：HP LoadRunner <span class="math inline">\(\rightarrow\)</span> HP Web Tours Application</p>
<ul>
<li>username: jojo</li>
<li>password: bean</li>
</ul>
<h5 id="virtual-user-generator">Virtual User Generator</h5>
<ul>
<li>Virtual User
Generator是一种基于<strong>录制回放</strong>的工具，可以把操作步骤录制下来，自动转化为脚本</li>
<li>在VuGen中录制得到的用户行为就是虚拟了一个用户的行为，称为Vuser，脚本称为Vuser
Script</li>
<li>VuGen进行用户行为模拟的流程</li>
</ul>
<h4 id="脚本录制">脚本录制</h4>
<h5 id="协议探测器">协议探测器</h5>
<p>错误的协议会导致Virtual User
Generator录制不到脚本、或录制的脚本不完整</p>
<p><strong>启动：</strong></p>
<p><img src="/2022/05/06/LoadRunner/image-20220506133720734.png" alt="image-20220506133720734" style="zoom:80%;"></p>
<h5 id="如何录制脚本">如何录制脚本</h5>
<p><strong>录制前准备</strong></p>
<ol type="1">
<li>启动测试环境</li>
<li>确定被测系统类型：可以通过探测器获取</li>
<li>录制采用的浏览器IE8</li>
<li>被测服务器地址</li>
</ol>
<p><strong>录制脚本</strong></p>
<blockquote>
<p>实现登录-退出操作</p>
</blockquote>
<p><strong>录制模式</strong></p>
<ol type="1">
<li><p><strong>HTML-base script</strong></p>
<p>一个<strong>页面</strong>录制一条语句(推荐浏览器项目)，更加简洁</p></li>
<li><p><strong>URL-based script</strong></p>
<p>一条客户端发起的<strong>请求</strong>录制一条语句(推荐非浏览器项目)，更加详细</p></li>
</ol>
<h5 id="脚本的组成及函数">脚本的组成及函数</h5>
<p><strong>Vugen脚本的组成</strong></p>
<ul>
<li>vuser_init：虚拟用户初始化，运行一次</li>
<li>action：具体操作，可迭代</li>
<li>vuser_end：结束操作，运行一次</li>
</ul>
<p><strong>函数</strong></p>
<p>脚本模式下，每行脚本都是函数</p>
<ul>
<li>web_url：直接请求一个网页</li>
<li>web_submit_data：用来生成表单的GET或POST请求</li>
<li>web_image：通过单击图片链接请求打开一个网页</li>
</ul>
<h5 id="脚本回放">脚本回放</h5>
<ul>
<li>运行脚本：
<ul>
<li>点击运行图标或F5运行</li>
</ul></li>
<li>查看结果：包含录制、回话、关联等相关信息的输出管理
<ul>
<li><strong>Repay
Log(回放日志)</strong>：脚本回放时记录的日志，可通过设置显示更多内容</li>
<li>Recording
Log(录制日志)：录制脚本时产生的日志，C/S通信的交互信息</li>
<li>Correlation
Results(关联结果)：脚本需要关联时，回放脚本的过程中记录的需要关联的值</li>
<li>Generation Log(生成日志)：脚本生成时产生的日志</li>
</ul></li>
</ul>
<p><img src="/2022/05/06/LoadRunner/image-20220507135042864.png" alt="image-20220507135042864" style="zoom:80%;"></p>
<h5 id="运行时设置run-time-settings">运行时设置(Run-time Settings)</h5>
<ul>
<li><p><strong>run logic(运行逻辑)</strong></p>
<ul>
<li><p>设置(Action的)迭代次数</p></li>
<li><p>可以添加其他Action(迭代次数影响所有Action)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代次数设置为三次</span></span><br><span class="line"><span class="built_in">vuser_init</span>();</span><br><span class="line"><span class="built_in">Action</span>();</span><br><span class="line"><span class="built_in">Action</span>();</span><br><span class="line"><span class="built_in">Action</span>();</span><br><span class="line"><span class="built_in">vuser_end</span>();</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>Pacing(等待时间)</strong></p>
<ul>
<li>设置每次迭代之间的等待时间</li>
</ul></li>
</ul>
]]></content>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试概述</title>
    <url>/2022/05/01/Software%20Testing/</url>
    <content><![CDATA[<h2 id="软件测试的内涵">软件测试的内涵</h2>
<h3 id="软件测试的重要性">软件测试的重要性</h3>
<p><strong>一、软件系统的层次性越来越复杂，上层系统越来越依赖于底层模块的稳健性</strong></p>
<p><strong>二、软件测试遍布于整个软件生命周期，无处不在</strong></p>
<p>软件测试已经从<u>编码阶段</u>前移到<u>需求分析</u>阶段，甚至前移到可行性论证阶段，同时后置到<u>日常维护阶段</u>，贯穿整个软件生命周期。</p>
<h3 id="软件测试的基本概念">软件测试的基本概念</h3>
<p><strong>一、广义的软件测试</strong></p>
<p>指软件<u>生存周期中所有的检查、评审和确认工作</u>，其中包括了对分析、设计阶段，以及完成开发后维护阶段的各类文档、代码的审查和确认</p>
<p><strong>二、狭义的软件测试</strong></p>
<p><u>识别软件缺陷的过程</u>，即实际结果与预期结果的不一致(常规：最早的测试是编码后的单元测试)</p>
<p><strong>三、软件测试通常包括<u>验证</u>和<u>确认</u></strong></p>
<p>验证(正确性测试)：指保证<u>软件正确地实现了某一特定功能</u>的一系列活动(是否和需求说明书流程一致)</p>
<p>确认(完整性测试)：指保证<u>软件的实现满足了用户需求</u>的一系列活动(是否功能完全覆盖)</p>
<blockquote>
<p>课后作业题：分析说明软件测试为何需要考虑广义测试而非狭义测试？</p>
<p>答：① 回答什么是广义测试，什么是狭义测试(见上面的概念一、二)</p>
<p>②
回答广义测试的重要性：广义的软件测试贯彻整个软件的开发生命周期，能够让项目组尽早开始测试用例的设计，发现软件设计中不易发现的各种缺陷和风险，保证整个软件开发过程中成果交付的质量；结合静态测试能发挥人的主观能动性，批量发现错误；总体上降低了软件开发风险，提高了软件质量。</p>
</blockquote>
<h3 id="软件测试的目的">软件测试的目的</h3>
<p>① 测试的目的是<u>发现软件中的各种缺陷</u></p>
<p>② 测试只能证明软件存在缺陷，<u>不能证明软件不存在缺陷</u></p>
<p>③ 测试可以使软件中缺陷<u>降低到一定程度，而不是彻底消灭</u></p>
<p>④
以<u>较少的用例、时间和人力</u>找出软件中的各种错误和缺陷，以确保软件质量</p>
<p>⑤ 以<u>更少的支出</u>来谋取收入支出比达到最大化</p>
<p>⑥
<strong>最终目标：确保软件功能符合用户需求，把尽可能多的问题在发布或交付前发现并改正</strong></p>
<h3 id="软件测试原则">软件测试原则</h3>
<p>① <strong>选择测试</strong>：权衡投入/产出比</p>
<p>②
<strong>有限测试</strong>：用有限的测试用例保证尽可能大的覆盖程度</p>
<p>③ 所有测试追溯到<strong>用户需求</strong></p>
<p>④ <strong>越早测试越好</strong>，测试过程与开发过程结合</p>
<p>⑤ <strong>测试规模由小到大</strong>，从单元测试到系统测试</p>
<p>⑥ 应由独立第三方来测试</p>
<p>⑦ 不能为了便于测试擅自修改程序</p>
<p>⑧ 测试软件应做什么和不应做什么</p>
<h3 id="软件测试的规律">软件测试的规律</h3>
<p><strong>一 、木桶原理与反木桶原理</strong></p>
<p>①
木桶原理：软件质量的关键因素是分析、设计和实现，测试属于补充检查手段，过度重视测试而忽视其他也会导致软件质量低下</p>
<p>②
反木桶原理：最长的模板决定其特色与优势，能够跳出大集团的游戏规则，独树一帜建立自己的王国</p>
<p><strong>二、Bug的80-20原则</strong></p>
<p>① 80%的工程量用在20%的需求上</p>
<p>② 80%的开发成本花费在20%的部件上</p>
<p>③ 80%的错误是由20%的部件引起的</p>
<p>④ 80%的延期或返工是由20%的变更造成的</p>
<p>⑤ 80%的系统资源是由20%的部件消耗的</p>
<p>⑥ 80%的进度是由20%的人完成的</p>
<h3 id="软件测试的重点">软件测试的重点</h3>
<p><strong>一、<u>测试用例</u>的良好设计</strong></p>
<p><strong>二、<u>测试工作</u>的管理(尤其针对包含多个子系统的测试)</strong></p>
<p><strong>三、<u>测试环境</u>的建立(应与实际环境一致)</strong></p>
<h3 id="软件测试的度量">软件测试的度量</h3>
<p><strong>一、测试覆盖率</strong></p>
<p><strong>二、缺陷发现率</strong></p>
<ul>
<li>缺陷数目</li>
<li>缺陷的严重性</li>
</ul>
<p><strong>三、测试成功率</strong></p>
<ul>
<li>已通过的测试用例的数目</li>
<li>可利用的测试用例的数目</li>
</ul>
<h3 id="软件测试误区和正确理解">软件测试误区和正确理解</h3>
<table>
<colgroup>
<col style="width: 44%">
<col style="width: 55%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">误区</th>
<th>正确理解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">软件开发完成后进行软件测试；软件测试=程序测试</td>
<td>软件测试是整个软件开发全生命周期的事情</td>
</tr>
<tr class="even">
<td style="text-align: left;">软件质量问题是测试人员的错误</td>
<td>软件质量问题是全体项目组共同的事情</td>
</tr>
<tr class="odd">
<td style="text-align: left;">测试技术要求不高，比编程容易，随便找一个人就行</td>
<td>测试人员要求有编程经验和对测试BUG
的敏感性；能够编写自动化测试脚本</td>
</tr>
<tr class="even">
<td style="text-align: left;">测试跟着开发动，有时间就多测，没时间就少测</td>
<td>必须有计划有组织</td>
</tr>
<tr class="odd">
<td style="text-align: left;">测试是测试人员的事，与开发人员无关</td>
<td>开发人员需要自测，还需要沟通协作</td>
</tr>
<tr class="even">
<td style="text-align: left;">软件测试是没有前途的工作，只有程序员才是软件高手</td>
<td>软件测试人员要求的素质往往要超过程序员</td>
</tr>
<tr class="odd">
<td style="text-align: left;">测试要执行所有可能的输入</td>
<td>穷举测试工作量太大，实践上行不通</td>
</tr>
<tr class="even">
<td style="text-align: left;">好的测试一定要使用很多的测试工具</td>
<td>工具所能发挥的作用依赖于使用工具的人</td>
</tr>
</tbody>
</table>
<h2 id="软件测试模型">软件测试模型</h2>
<p><img src="/2022/05/01/Software%20Testing/image-20220501234416875.png" alt="image-20220501234416875" style="zoom:80%;"></p>
<h3 id="软件测试技术必考">软件测试技术(必考)</h3>
<h4 id="一黑盒测试-vs-白盒测试从要不要看代码部分来区分">一、黑盒测试 vs
白盒测试：<u>从要不要看代码部分来区分</u></h4>
<blockquote>
<p>黑盒测试，又称功能测试和数据驱动测试，是在<u>已知软件产品具有何种功能</u>的前提下，用来<u>检验每个功能能否正确</u>使用的一个测试方法。</p>
<p>主要工作：检查实现功能与实际需求的满足程度(确认和验证的过程)</p>
<p>测试方法/原理：把程序看作不能打开的黑盒子，在<u>不考虑程序内部结构</u>的情况下，用操作接口的方式进行测试，检验程序能否按照需求制定的功能接受输入数据并产生正确结果。</p>
<figure>
<img src="/2022/05/01/Software%20Testing/image-20220501235602507.png" alt="image-20220501235602507">
<figcaption aria-hidden="true">image-20220501235602507</figcaption>
</figure>
<p>黑盒测试主要在<u>开发后期</u>进行。基于对需求、设计、用户要求的理解</p>
</blockquote>
<hr>
<blockquote>
<p>白盒测试，又称结构测试或逻辑驱动测试，<u>必须知道软件内部工作过程</u>，通过测试检测软件内部是否按照需求、设计正常运行。</p>
<p>主要工作：代码检查(语法、逻辑、书写)，静态结构分析(系统结构、函数调用关系)，功能确认与接口分析，逻辑覆盖率分析，性能与效率分析，内存分析</p>
<p>测试方法/原理：通过逻辑覆盖、路径覆盖等方式选择测试用例，可以用<u>测试覆盖率</u>评价测试用例</p>
<figure>
<img src="/2022/05/01/Software%20Testing/image-20220502000324686.png" alt="image-20220502000324686">
<figcaption aria-hidden="true">image-20220502000324686</figcaption>
</figure>
</blockquote>
<h4 id="二动态测试-vs-静态测试从要不要运行软件来区分">二、动态测试 vs
静态测试：<u>从要不要运行软件来区分</u></h4>
<blockquote>
<p>静态测试(看代码)：<u>不执行程序</u>来寻找代码种存在的错误或评估代码的过程。由人工进行，发挥人的逻辑思维和测试经验优势。能够批量性发现问题，或直接定位到错误的具体位置。</p>
<p>主要工作：代码检查、静态结构分析、代码质量度量</p>
</blockquote>
<hr>
<blockquote>
<p>动态测试(跑代码)：<u>必须生成测试数据来运行被测试的数据</u>，取得程序运行的真实情况、动态情况。生成测试数据、分析测试结果工作量大、费时、费力、废人</p>
</blockquote>
<h4 id="三手工测试-vs-自动化测试从是否需要人工介入来区分">三、手工测试
vs 自动化测试：<u>从是否需要人工介入来区分</u></h4>
<blockquote>
<p>手工测试：属于传统测试方法，由测试人员手工编写测试用例。缺点是工作量大、重复多，回归测试困难</p>
</blockquote>
<hr>
<blockquote>
<p>自动化测试：利用软件测试工具自动实现全部或部分测试工作：管理、设计、执行和报告。</p>
<p>自动化测试节省大量测试开销，并且能够完成一些手工测试无法实现的测试(如回归测试)。</p>
<p>自动化测试前必须首先手工测试(调试到适合进行自动化测试的环境)</p>
<p>缺点：无法及时进行动态调整和梳理分析(计算正确不代表逻辑没错)</p>
<p>分类：</p>
<ul>
<li>录制/回放：人工完成一遍测试数据，由自动测试工具记录交互过程形成脚本，然后再测试时，直接进行回放。缺点是数据和脚本混在一起，维护成本很高，界面变化时需要重新录入脚本。</li>
</ul>
<p><img src="/2022/05/01/Software%20Testing/image-20220502001857268.png" alt="image-20220502001857268" style="zoom:80%;"></p>
<ul>
<li>脚本技术：一组测试工具执行的指令集合。脚本通过录制程序产生脚本，然后再做修改。</li>
<li>数据驱动技术：在脚本技术的基础上，实现数据与脚本分离。</li>
<li><strong>关键字驱动技术(主流)</strong>：在数据驱动的基础上进行改进，将测试逻辑按照关键字进行分解</li>
<li>业务驱动技术：J2EE多层架构技术等</li>
</ul>
</blockquote>
<h2 id="软件测试流程">软件测试流程</h2>
<ol type="1">
<li><p>制定测试大纲；</p></li>
<li><p>制作测试数据；</p></li>
<li><p>单元测试（程序测试）：<strong>白盒测试、功能测试</strong>；</p></li>
<li><p>集成测试（子系统测试）：<strong>白盒和黑盒测试、功能测试</strong>；</p></li>
<li><p>系统测试：<strong>黑盒测试、功能测试、性能测试</strong>；</p></li>
<li><p><strong>回归测试</strong>：<strong>黑盒测试、功能测试、性能测试</strong>；</p></li>
<li><p>验收测试；</p></li>
<li><p>写出测试报告书；</p></li>
<li><p>向下阶段工作提交系统运行、维护手册等。</p></li>
</ol>
<h3 id="v模型重点">V模型(重点)</h3>
<p><img src="/2022/05/01/Software%20Testing/image-20220502002729617.png" alt="image-20220502002729617" style="zoom:80%;"></p>
<blockquote>
<p>课后作业：结合V模型谈谈软件开发和软件测试之间的关系</p>
<p>答：①
在V模型中，详细设计阶段就会规划单元测试计划。单元是程序中可以独立存在的最小程序体，例如详细设计中设计的每个程序模组(可能是一个方法)，单元测试可以测试其能否正常运作。</p>
<p>②
概要设计阶段会规划集成测试计划，集成测试会验证独立的各个程序模组能否共存</p>
<p>③
需求分析阶段会规划系统测试计划，系统测试会确保开发的软件符合预期的需求</p>
</blockquote>
<h3 id="测试流程拆解">测试流程拆解</h3>
<blockquote>
<p>单元测试：完成对<u>最小软件设计单元</u>/模块的验证工作，确保<u>模块被正确地编码</u></p>
<p>测试内容：接口测试、内部数据结构、全局数据结构、<u>边界值分析、语句覆盖、错误路径</u>(处理异常的路径)</p>
<p>测试特点：使用<u>过程设计描述</u>作为指南，对重要控制路径进行测试以发现模块内的错误，通常<u>面向白盒</u></p>
<p>必要性：对代码风格和规则、程序设计和结构、业务逻辑进行测试，<u>尽早发现和解决不易显现的错误</u></p>
</blockquote>
<hr>
<blockquote>
<p>集成测试：通过测试发现<u>与模块接口有关的问题</u>，把通过单元测试的模块构造一个集成的程序结构</p>
<p>测试内容：API、API/参数组合、子模块</p>
<p>测试特点：<u>避免一次性集成，而应采用增量集成</u></p>
</blockquote>
<hr>
<blockquote>
<p>系统测试：根据软件需求规范的要求测试，<u>确认系统满足需求的要求</u></p>
<p>测试内容：所有功能需求得到满足、所有性能需求得到满足、其他需求得到满足</p>
<p>测试特点：系统测试人员相当于<u>用户代言人</u>，需要<u>在需求分析阶段确定软件的可测性</u></p>
</blockquote>
<hr>
<blockquote>
<p>用户验收/确认测试：<strong>配置审查</strong>(确保已开发软件的所有文件资料均已编写齐全，并分类编目)、<strong>Alpha测试</strong>(由用户在开发者的场所进行，测试环境受控)、<strong>Beta测试</strong>(由最终用户在一个或多个用户场所进行，用户记录测试种的问题并报告给开发者)</p>
</blockquote>
<hr>
<blockquote>
<p>回归测试：<u>发现并修改缺陷或软件添加新功能后</u>，重新测试，检查被发现的缺陷是否被改正，并且所作的修改是否引发新的问题</p>
<p>测试方式：<strong>再测试全部用例</strong>(选择基线测试用例库的全部测试用例组成回归测试包，成本极高)，<strong>基于风险选择测试</strong>(基于一定风险标准选择测试用例组成回归测试包)</p>
<p>测试特点：可以通过人工重新执行测试用例，也可以使用自动化测试工具回放进行</p>
</blockquote>
<h2 id="软件测试过程">软件测试过程</h2>
<p>拟定软件<u>测试计划/方案</u> <span class="math inline">\(\rightarrow\)</span> 设计和生成<u>测试用例</u>
<span class="math inline">\(\rightarrow\)</span>
<u>执行测试</u>，记录数据，进行缺陷管理 <span class="math inline">\(\rightarrow\)</span>
生成<u>测试报告</u>，缺陷统计报表</p>
<h3 id="测试计划">测试计划</h3>
<p>① <u>时间进度、人员安排、风险管理</u></p>
<p>② 测试<u>范围的确定</u>、测试<u>数据的生成</u></p>
<p>③ 测试<u>工具、方法的选择</u>和工具开发</p>
<p>④ 测试<u>完成标准</u></p>
<p>⑤ 影响<u>资源分配</u>的特殊考虑</p>
<h3 id="测试方案">测试方案</h3>
<p>定义被测软件功能以及相关的测试，并<u>详细说明的测试方法和策略</u></p>
<h3 id="测试用例">测试用例</h3>
<p>为实施一次测试而<u>向被测系统提供的输入数据、操作或各种环境设置</u>，控制软件测试的执行步骤，对测试方案中每个测试项进一步实例化</p>
<p>基本准则：<u>代表性</u>(等价类划分)、<u>可判定性</u>(都有相应的期望结果)、<u>可再现性</u>(可逆操作)</p>
<h3 id="软件测试的执行">软件测试的执行</h3>
<p>执行测试用例 <span class="math inline">\(\rightarrow\)</span>
记录原始测试数据 <span class="math inline">\(\rightarrow\)</span>
记录缺陷 <span class="math inline">\(\rightarrow\)</span>
对所发现的缺陷进行跟踪</p>
<h3 id="测试评估">测试评估</h3>
<p>结合量化的测试覆盖率及缺陷跟踪报告，<u>对整个软件质量、测试工作和软件缺陷进行总结</u></p>
]]></content>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux三剑客之awk</title>
    <url>/2022/05/18/awk/</url>
    <content><![CDATA[<h3 id="简介">1. 简介</h3>
<p>awk是一门<strong>编程语言</strong>，主要应用领域为数据<strong>过滤、统计和计算</strong>，在系统中通常用来处理日志数据。</p>
<p>使用命令 <code>man awk</code> 查看awk的详细信息</p>
<h3 id="执行过程">2. 执行过程</h3>
<h4 id="示例代码">2.1 示例代码</h4>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BEGIN&#123;<span class="built_in">print</span> <span class="string">&quot;name&quot;</span>&#125; 打印<span class="string">&#x27;name&#x27;</span>字符串</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125; 打印每一行的第二列，前面可以加上条件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">END&#123;<span class="built_in">print</span> <span class="string">&quot;end of file&quot;</span>&#125; 打印EOF</span></span><br><span class="line">awk -F, &#x27;BEGIN&#123;print &quot;name&quot;&#125;&#123;print $2&#125;END&#123;print &quot;end of file&quot;&#125;&#x27; test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">带条件的awk命令，指定打印第二行第二列内容</span></span><br><span class="line">awk -F, &#x27;BEGIN&#123;print &quot;name&quot;&#125;NR==2&#123;print $2&#125;END&#123;print &quot;end of file&quot;&#125;&#x27; test.txt</span><br></pre></td></tr></table></figure></div>
<h4 id="流程">2.2 流程</h4>
<p><strong>读取文件之前</strong>：进行命令行赋值或设置命令行参数，并运行BEGIN{}方法体</p>
<p><strong>读取文件过程</strong>：读取文件内容 <span class="math inline">\(\rightarrow\)</span> 判断是否满足结束条件 <span class="math inline">\(\rightarrow\)</span> 不满足则继续读取下一行 <span class="math inline">\(\rightarrow\)</span> EOF</p>
<p><strong>读取文件之后</strong>：运行END{}方法体</p>
<h3 id="常用操作">3. 常用操作</h3>
<h4 id="行和列">3.1 行和列</h4>
<p><strong>行</strong>：在awk中称为记录(record)，每一行默认通过回车分割</p>
<p><strong>列</strong>：在awk中称为字段/域(field)，每一列默认通过空格分割</p>
<blockquote>
<p>awk中的行列结束标记都可以修改</p>
</blockquote>
<h5 id="取行">3.1.1 取行</h5>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">NR：行号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">符号包括 &gt; &lt; &lt;= &gt;= == !=</span></span><br><span class="line">NR == 1 # 取出第一行</span><br><span class="line">NR &gt;= 1 &amp;&amp; NR &lt;= 5 # 取出1~5行</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接索引</span></span><br><span class="line">awk &#x27;/kjournald/&#x27; test.txt # 取出所有带有&#x27;kjournald&#x27;记录</span><br></pre></td></tr></table></figure></div>
<h5 id="取列">3.1.2 取列</h5>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-F 指定分隔符(默认为空格/连续的空格/tab键)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$1</span> 取出第1列</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$0</span> 表示整行的内容</span></span><br><span class="line">awk &#x27;&#123;print $6&#125;&#x27; test.txt # 取出第6列的全部内容</span><br><span class="line">awk NR==2&#x27;&#123;print $0&#125;&#x27; test.txt # 取出第2行的全部内容</span><br><span class="line">awk &#x27;&#123;print $1,$2&#125;&#x27; test.txt # 取出第1列和第2列的全部内容</span><br><span class="line">awk &#x27;&#123;print $1,$3,$5&#125;&#x27; test.txt |column -t # 取出第1,3,5列的全部内容，并进行对齐</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">NF：每行有多少字段</span></span><br><span class="line">awk &#x27;&#123;print $NF&#125;&#x27; test.txt # 取最后一列</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果间可以自定义分隔符</span></span><br><span class="line">awk &#x27;&#123;print $1 &quot;@&quot; $3&#125;&#x27; test.txt # 取出第1,3列，并以@分割</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">OFS: OutPut Field Separator，输出时的分隔符，默认为空格</span></span><br><span class="line">awk -F: -vOFS=: &#x27;&#123;print $NF,$2,$3,$4,$5,$6,$1&#125;&#x27; test.txt # 输出时默认以:分割</span><br></pre></td></tr></table></figure></div>
<h4 id="awk模式匹配">3.2 awk模式匹配</h4>
<p>了解awk的条件有哪些情况：</p>
<ul>
<li>比较符号： &gt; &lt; &gt;= &lt;= == !=</li>
<li>正则表达式</li>
<li>范围表达式</li>
<li>特殊条件：BEGIN{} END{}</li>
</ul>
<h5 id="比较表达式">3.2.1 比较表达式</h5>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;NR&gt;=1 &amp;&amp; NR &lt;=3&#x27; test.txt</span><br></pre></td></tr></table></figure></div>
<h5 id="正则">3.2.2 正则</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">正则</th>
<th style="text-align: center;">awk正则</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">^ 表示以...开头的行</td>
<td style="text-align: center;">某一列的开头</td>
</tr>
<tr class="even">
<td style="text-align: center;">$ 表示以...结尾的行</td>
<td style="text-align: center;">某一列的结尾</td>
</tr>
<tr class="odd">
<td style="text-align: center;">^$表示空行</td>
<td style="text-align: center;">某一列的空(少用)</td>
</tr>
</tbody>
</table>
<ul>
<li>支持扩展正则</li>
<li>awk的正则可以精确到行，指定包含或不包含指定内容</li>
<li>~包含</li>
<li>!~不包含</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出第3列以1开头的行</span></span><br><span class="line">awk -F: &#x27;$3~/^1/&#x27; /etc/passwd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到第3列以2开头的行，并显示第1列，第3列和最后一列</span></span><br><span class="line">awk -F: &#x27;$3~/^2/&#123;print $1,$3,$NF&#125;&#x27; /etc/passwd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到第3列以1或2开头的行</span></span><br><span class="line">awk -F: &#x27;$3~/^[12]/&#123;print $1,$3,$NF&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure></div>
<h5 id="范围表达式">3.2.3 范围表达式</h5>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/哪里开始/,/哪里结束/ (最常用的语法)</span></span><br><span class="line">awk &#x27;/11:02:00/,/11:02:30/&#123;print $1&#125;&#x27; access.log # 打印30秒内日志的第一行</span><br></pre></td></tr></table></figure></div>
<h5 id="特殊模式begin和end">3.2.3 特殊模式BEGIN{}和END</h5>
<p><strong>BEGIN{}</strong>：awk读取文件前执行，用于：</p>
<ul>
<li>进行简单统计/计算，</li>
<li>添加表头</li>
<li>用来定义awk变量(少用，一般用-v)</li>
</ul>
<p><strong>END{}</strong>：awk读取文件后执行，用于：</p>
<ul>
<li>进行统计，输入计算结果</li>
<li>awk使用数组，用来输出数组的结果</li>
</ul>
<table>
<thead>
<tr class="header">
<th>统计方法</th>
<th>简写形式</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>i = i + 1</td>
<td>i++</td>
<td>计数</td>
</tr>
<tr class="even">
<td>sum = sum + ?</td>
<td>sum += ?</td>
<td>求和</td>
</tr>
<tr class="odd">
<td>array[] = array[] + 1</td>
<td>array[]++</td>
<td>数组分类计数</td>
</tr>
</tbody>
</table>
<blockquote>
<p>sum和i都是<strong>变量</strong></p>
</blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计 /etc/services里有多少个空行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">i++ 每行进行统计 | <span class="built_in">print</span> i 输出结果</span> </span><br><span class="line">awk &#x27;/^$/&#123;i++&#125;END&#123;print i&#125;&#x27; /etc/services</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">计算1+2+3+...+100</span></span><br><span class="line">seq 100|awk &#x27;&#123;sum += $1&#125;END&#123;print sum&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看过程</span></span><br><span class="line">seq 100|awk &#x27;&#123;sum += $1;print sum&#125;END&#123;print sum&#125;&#x27;</span><br></pre></td></tr></table></figure></div>
<h4 id="awk数组">3.3 awk数组</h4>
<ul>
<li>统计日志：统计每个ip出现次数，统计每种状态码的出现次数，统计攻击者ip出现次数</li>
<li>统计每个ip消耗的流量</li>
</ul>
<table>
<colgroup>
<col style="width: 5%">
<col style="width: 55%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th>shell数组</th>
<th>awk数组</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">形式</td>
<td>array[0] = token1 array[1] = token2</td>
<td>array[0] = token1 array[1] = token2</td>
</tr>
<tr class="even">
<td style="text-align: center;">使用</td>
<td>echo ${array[0]} $(array[1]}</td>
<td>print array[0] array[1]</td>
</tr>
<tr class="odd">
<td style="text-align: center;">批处理</td>
<td>for i in ${array[*]} <br>do <br> echo $i<br>done</td>
<td>for(i in array)<br> print array[i]</td>
</tr>
</tbody>
</table>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">错误写法：awk中所有字母都被识别为变量，字符串需要使用双引号围绕</span></span><br><span class="line">awk &#x27;BEGIN&#123;a[0]=token1;a[1]=token2;print a[0],a[1]&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正确写法</span></span><br><span class="line">awk &#x27;BEGIN&#123;a[0]=&quot;token1&quot;;a[1]=&quot;token2&quot;;print a[0],a[1]&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批处理</span></span><br><span class="line">awk &#x27;BEGIN&#123;a[0]=&quot;token1&quot;;a[1]=&quot;token2&quot;;for(i in a) print a[i]&#125;&#x27;</span><br></pre></td></tr></table></figure></div>
<h5 id="范例一">范例一</h5>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">处理以下文件内容，取出域名并进行计数和排序处理</span></span><br><span class="line">http://www.etiantian.org/index.html</span><br><span class="line">http://www.etiantian.org/index.html</span><br><span class="line">http://post.etiantian.org/index.html</span><br><span class="line">http://mp3.etiantian.org/index.html</span><br><span class="line">http://www.etiantian.org/3.html</span><br><span class="line">http://post.etiantian.org/2.html</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要计算</span></span><br><span class="line">www.etiantian.org 出现次数</span><br><span class="line">post.etiantian.org 出现次数</span><br><span class="line">mp3.etiantian.org 出现次数</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">代码</span></span><br><span class="line">awk -F/ &#x27;&#123;array[$3]++&#125;END&#123;for(i in array) print i,array[i]&#125;&#x27; test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出结果</span></span><br><span class="line">mp3.etiantian.org 1</span><br><span class="line">www.etiantian.org 3</span><br><span class="line">post.etiantian.org 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">排序</span></span><br><span class="line">awk -F/ &#x27;&#123;array[$3]++&#125;END&#123;for(i in array) print i,array[i]&#125;&#x27; test.txt|sort -rnk2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出结果</span></span><br><span class="line">www.etiantian.org 3</span><br><span class="line">post.etiantian.org 2</span><br><span class="line">mp3.etiantian.org 1</span><br></pre></td></tr></table></figure></div>
<h4 id="awk循环和判断">3.4 awk循环和判断</h4>
<h5 id="for循环">3.4.1 for循环</h5>
<table>
<colgroup>
<col style="width: 56%">
<col style="width: 43%">
</colgroup>
<thead>
<tr class="header">
<th>shell的c语言for循环</th>
<th>awk的for循环</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>for((i = 1; i &lt;= 10; i++)) <br>do<br> echo $n<br>done</td>
<td>for(int i = 1; i &lt;= 10; i++)<br> print i</td>
</tr>
</tbody>
</table>
<p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;</span><br><span class="line">for(i=1;i&lt;=100;i++)</span><br><span class="line">	sum+=i; </span><br><span class="line">	print sum;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure></div></p>
<h5 id="if判断">3.4.2 if判断</h5>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 49%">
</colgroup>
<thead>
<tr class="header">
<th>shell if判断</th>
<th>awk if判断</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>if["token -eq 18"]; then <br> echo take to do sth<br>else<br>
echo "rest"<br>pass</td>
<td>if(condition)<br> print sth<br>else<br> print other</td>
</tr>
</tbody>
</table>
<h5 id="范例2">范例2</h5>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计这段语句中，单词中字符数小于6的单词，并显示</span></span><br><span class="line">echo I am a student studing in XMU university</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">代码 length(<span class="variable">$i</span>) 统计第i列的长度</span></span><br><span class="line">echo I am a student studing in XMU university. |awk &#x27;&#123;for(i=1;i&lt;=NF;i++)&#123;if(length($i) &lt;6) print $i&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure></div>
<h3 id="awk总结">4. awk总结</h3>
<ul>
<li><p>awk选项 -F -v</p></li>
<li><p>awk执行流程</p></li>
<li><p>awk取行取列</p></li>
<li><p>awk模式：正则、范围、特殊模式</p></li>
<li><p>awk数组</p></li>
<li><p>awk控制：for / if</p></li>
<li><p>awk帮助：man awk / info awk</p></li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/04/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>序列化和反序列化</title>
    <url>/2022/04/29/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h4 id="序列化和反序列化的定义">序列化和反序列化的定义</h4>
<p><strong>序列化</strong>：把对象转化为可传输的字节序列的过程</p>
<p><strong>反序列化</strong>：把字节序列还原为对象的过程</p>
<hr>
<h4 id="为什么要序列化">为什么要序列化</h4>
<p><strong>目的</strong>：让对象可以<strong>跨平台存储</strong>和进行<strong>网络传输</strong></p>
<p><strong>因果</strong>：网络传输的方式是I/O <span class="math inline">\(\rightarrow\)</span> I/O支持的数据格式为字节数组
<span class="math inline">\(\rightarrow\)</span>
对象要传输需要序列化为字节序列</p>
<p><strong>规范</strong>：序列化需要遵循规则，使得传输到目的地的字节序列能通过该规则反序列化还原为对象</p>
<hr>
<h4 id="需要序列化的场景">需要序列化的场景</h4>
<p>凡是需要<strong>跨平台存储</strong>和<strong>网络传输</strong>的数据，都需要序列化</p>
<p>网络传输本质：对象 <span class="math inline">\(\rightarrow\)</span>
字节序列 <span class="math inline">\(\rightarrow\)</span> 网络 <span class="math inline">\(\rightarrow\)</span> 字节序列 <span class="math inline">\(\rightarrow\)</span> 对象</p>
<p>跨平台存储本质：对象 <span class="math inline">\(\rightarrow\)</span>
跨平台字节码 <span class="math inline">\(\rightarrow\)</span> 跨平台
<span class="math inline">\(\rightarrow\)</span> 跨平台字节码 <span class="math inline">\(\rightarrow\)</span> 对象</p>
<hr>
<h4 id="序列化的选择">序列化的选择</h4>
<p><strong>常见的序列化方式</strong></p>
<p>不支持跨语言：JDK、Kryo、FST</p>
<p>支持跨语言：JSON、Hessian、Thrift、Protostuff</p>
<p><strong>序列化的速度</strong></p>
<p>如果一个项目中需要序列化的场景很多，那么选择序列化效率高的协议能显著提高系统性能</p>
<p><strong>序列化字节序列的大小</strong></p>
<p>数据越小越好，传输快，提升系统性能</p>
<hr>
<h4 id="java中的序列化">Java中的序列化</h4>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java中要实现序列化，只需要实现Serializable接口即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 需要注意的问题</span></span><br><span class="line"><span class="comment"> * 1. static属性不能被序列化</span></span><br><span class="line"><span class="comment"> * 序列化保存的是对象的状态，静态变量属于类的状态，因此序列化不保存静态变量</span></span><br><span class="line"><span class="comment"> * 2. transient属性不会被序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ElemType t;</span><br><span class="line">    <span class="keyword">private</span> ElemType e;    </span><br><span class="line">    <span class="comment">// 经过序列化和反序列化，t中的值会丢失(t == null)，e中的值不会丢失(e == something)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="序列化版本号serialversionuid">序列化版本号serialVersionUID</h4>
<p>所有实现序列化的对象都必须有一个版本号，可以自定义，否则JDK工具会按照对象属性自动生成</p>
<p><strong>版本号的用途</strong></p>
<p>在序列化业务需求发生变化后，通过修改版本号告诉反序列化一方的对象需要同步修改</p>
<p><strong>JDK自动生成的版本号和我们自定义的版本号的区别</strong></p>
<p>JDK根据对象的属性信息生成版本号，意味着对象的属性和序列化版本号会同步改变</p>
<p>坏处：只要对象有一点小变动版本号就会变更，用户必须强制更新软件，而现实需求应该是：<strong>用户可以选择不更新，不更新仅仅无法体验新增加的功能而已</strong>，而这时候就需要我们自定义的版本号了，<strong>只要序列化版本一样，对象新增属性不会影响反序列化对象</strong>。</p>
<hr>
<h4 id="父类子类序列化问题">父类、子类序列化问题</h4>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.父类不实现序列化，子类实现序列化</span></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String hobby;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化后再反序列化</span></span><br><span class="line"><span class="comment">// 最终结果：父类结果未被序列化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.父类实现序列化，子类不实现序列化</span></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String hobby;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化后再反序列化</span></span><br><span class="line"><span class="comment">// 最终结果：子类属性序列化正常</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>白盒测试</title>
    <url>/2022/05/08/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="白盒测试">白盒测试</h2>
<p>白盒测试把程序视为一个<strong>透明的盒子</strong>，根据<strong>程序内部结构</strong>设计测试用例，测试需要<strong>覆盖全部代码的分支、路径和条件</strong></p>
<p><img src="/2022/05/08/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220502000324686.png" alt="image-20220502000324686" style="zoom:67%;"></p>
<p>白盒测试有<u>静态测试和动态测试</u>两种方法</p>
<h2 id="静态测试程序结构分析">静态测试(程序结构分析)</h2>
<h5 id="代码走查一组程序-错误检查技术">代码走查：一组程序 +
错误检查技术</h5>
<p>人员：组长(分配资料、安排计划) + 资深程序员 + 测试人员 +
程序开发员</p>
<p>内容：探讨代码编写思路</p>
<h5 id="代码审查">代码审查</h5>
<ol type="1">
<li>检查代码和设计的一致性</li>
<li>代码可读性</li>
<li>代码逻辑正确性</li>
<li>代码结构合理性</li>
<li>公司整理的易错点checklist</li>
</ol>
<p>步骤：准备 <span class="math inline">\(\rightarrow\)</span> 程序阅读
<span class="math inline">\(\rightarrow\)</span> 审查会 <span class="math inline">\(\rightarrow\)</span> 跟踪报告</p>
<h5 id="控制流分析检查程序的控制结构">控制流分析：检查程序的控制结构</h5>
<ul>
<li><p><strong>程序流程图</strong></p>
<p><img src="/2022/05/08/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220508123614063.png" alt="image-20220508123614063" style="zoom:67%;"></p></li>
<li><p><strong>控制流图(必考)</strong></p></li>
</ul>
<p><img src="/2022/05/08/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220317170655642.png" alt="image-20220317170655642" style="zoom:60%;"></p>
<ul>
<li><strong>控制流图矩阵(控制流图的矩阵形式)</strong></li>
</ul>
<p><img src="/2022/05/08/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220317170914579.png" alt="image-20220317170914579" style="zoom:67%;"></p>
<h5 id="数据流分析程序错误">数据流分析(程序错误)</h5>
<ul>
<li><p>如果某一语句执行能<strong>改变变量x的值</strong>，则称x被该语句<strong>定义</strong></p></li>
<li><p>如果某一语句执行了<strong>内存中变量x的值</strong>，则称x被该语句<strong>引用</strong></p></li>
<li><p>常见的程序错误有：错拼名字、名字混淆、语句丢失等(一般都是编译器能检测的错误)</p></li>
</ul>
<h5 id="信息流分析">信息流分析</h5>
<ul>
<li>检查是否存在无用的语句</li>
</ul>
<h2 id="动态测试逻辑覆盖">动态测试(逻辑覆盖) ★★★★★</h2>
<p>考虑如下程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(A &gt; <span class="number">1</span> &amp;&amp; B == <span class="number">0</span>)</span><br><span class="line">	X = X/A;</span><br><span class="line"><span class="keyword">if</span>(A == <span class="number">2</span> || X &gt; <span class="number">1</span>)</span><br><span class="line">	X = X + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>其程序流程图为：</p>
<p><img src="/2022/05/08/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220317171842004.png" alt="image-20220317171842004" style="zoom:67%;"></p>
<h3 id="语句覆盖">语句覆盖</h3>
<p>设计若干个设计用例，然后运行被测程序，<strong>使程序中每个可执行语句至少执行一次</strong></p>
<p><img src="/2022/05/08/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/Inkedimage-20220317171842003_LI.jpg" alt="Inkedimage-20220317171842003_LI" style="zoom:67%;"></p>
<p><strong>解释</strong>：蓝色的路径覆盖了所有<strong>语句</strong>(b和d路径上没有语句)，这条测试用例则实现了100%语句覆盖</p>
<p><strong>测试用例</strong>：A = 2，B = 0，X = 3</p>
<blockquote>
<p>注意：用<strong>尽量少</strong>的设计用例覆盖所有可执行语句</p>
<p>语句覆盖率 = 已执行 / 可执行 * 100%</p>
</blockquote>
<p><strong>优点</strong>：检查所有语句、简单易行、覆盖率高</p>
<p><strong>缺点</strong>：以下是语句覆盖无法检测的错误</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARMASM"><figure class="iseeu highlight /armasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 条件语句错误</span></span><br><span class="line">A &gt; <span class="number">1</span> &amp;&amp; <span class="keyword">B</span> == <span class="number">0</span> -&gt; A &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">B</span> == <span class="number">0</span></span><br><span class="line"><span class="comment">// 逻辑运算错误</span></span><br><span class="line">A &gt; <span class="number">1</span> &amp;&amp; <span class="keyword">B</span> == <span class="number">0</span> -&gt; A &gt; <span class="number">1</span> <span class="title">||</span> <span class="keyword">B</span> == <span class="number">0</span></span><br><span class="line"><span class="comment">// 循环次数错误</span></span><br><span class="line"><span class="symbol">for</span>(int i = <span class="number">0</span><span class="comment">; i &lt; n; i++) -&gt; for(int i = 0; i &lt;= n; i++)</span></span><br></pre></td></tr></table></figure></div>
<h3 id="分支覆盖">分支覆盖</h3>
<p>分支覆盖又称判定覆盖，<strong>程序流程图中每条边走一遍</strong></p>
<p><img src="/2022/05/08/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/Inkedimage-20220317171842003_LI-1651985586292.jpg" alt="Inkedimage-20220317171842003_LI" style="zoom:67%;"></p>
<p><strong>解释</strong>：直观上看，就是把流程图所有能覆盖的线全部覆盖住，则分支覆盖就能达到100%</p>
<table>
<thead>
<tr class="header">
<th>测试用例</th>
<th>覆盖路径</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A = 2, B = 0, X = 3</td>
<td>ace(蓝色)</td>
</tr>
<tr class="even">
<td>A = 1, B = 0, X = 1</td>
<td>abd(红色)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>分支覆盖率 = 已判定 / 总判定</p>
<p>分支覆盖的测试用例划分不止一种</p>
<p>纠错能力比语句覆盖好一些</p>
</blockquote>
<h3 id="条件覆盖">条件覆盖</h3>
<p>使得被测程序每个判断中的<strong>每个条件的可能取值至少要满足一次</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">第一个条件</span></span><br><span class="line"><span class="attr">T1:</span> <span class="string">A</span> <span class="string">&gt;</span>  <span class="number">1</span>  </span><br><span class="line"><span class="attr">F1:</span> <span class="string">A</span> <span class="string">&lt;=</span> <span class="number">1</span></span><br><span class="line"><span class="attr">T2:</span> <span class="string">B</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line"><span class="attr">F2:</span> <span class="string">B</span> <span class="type">!=</span> <span class="number">0</span></span><br><span class="line"><span class="string">//</span> <span class="string">第二个条件</span></span><br><span class="line"><span class="attr">T3:</span> <span class="string">A</span> <span class="string">==</span> <span class="number">2</span></span><br><span class="line"><span class="attr">F3:</span> <span class="string">A</span> <span class="type">!=</span> <span class="number">2</span></span><br><span class="line"><span class="attr">T4:</span> <span class="string">X</span> <span class="string">&gt;</span>  <span class="number">1</span></span><br><span class="line"><span class="attr">F4:</span> <span class="string">X</span> <span class="string">&lt;=</span> <span class="number">1</span></span><br><span class="line"><span class="string">//</span> <span class="string">缺点：不能实现对每个分支的检查，用例数量增加</span></span><br></pre></td></tr></table></figure></div>
<p><img src="/2022/05/08/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/Inkedimage-20220317171842003_LI-1651986336995.jpg" alt="Inkedimage-20220317171842003_LI" style="zoom:67%;"></p>
<p><strong>为什么需要abe？</strong></p>
<p><strong>解释</strong>：因为仅有ace和abd的情况下，条件F2和F4没有被测试，而条件覆盖要求<strong>所有条件的正反面都要至少被测试一次</strong>。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">用例编号</th>
<th style="text-align: center;">ABX</th>
<th style="text-align: center;">路径</th>
<th style="text-align: center;">覆盖条件</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">203</td>
<td style="text-align: center;">ace</td>
<td style="text-align: center;">T1 T2 T3 T4</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">101</td>
<td style="text-align: center;">abd</td>
<td style="text-align: center;">F1 T2 F3 T4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">211</td>
<td style="text-align: center;">abe</td>
<td style="text-align: center;">T1 <strong>F2</strong> T3
<strong>F4</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p>条件覆盖不是分支覆盖的超集</p>
</blockquote>
<h3 id="分支-条件覆盖">分支-条件覆盖</h3>
<p>顾名思义，分支覆盖 + 条件覆盖</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARMASM"><figure class="iseeu highlight /armasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个分支</span></span><br><span class="line">(<span class="number">1</span>) A &gt; <span class="number">1</span>,  <span class="keyword">B</span> == <span class="number">0</span>, 记为T1, T2</span><br><span class="line">(<span class="number">2</span>) A &gt; <span class="number">1</span>,  <span class="keyword">B</span> != <span class="number">0</span>, 记为T1, <span class="built_in">F2</span></span><br><span class="line">(<span class="number">3</span>) A &lt;= <span class="number">1</span>, <span class="keyword">B</span> == <span class="number">0</span>, 记为<span class="built_in">F1</span>, T2</span><br><span class="line">(<span class="number">4</span>) A &lt;= <span class="number">1</span>, <span class="keyword">B</span> != <span class="number">0</span>, 记为<span class="built_in">F1</span>, <span class="built_in">F2</span></span><br><span class="line"><span class="comment">// 第二个分支</span></span><br><span class="line">(<span class="number">5</span>) A == <span class="number">2</span>, X &gt;  <span class="number">1</span>, 记为T3, T4</span><br><span class="line">(<span class="number">6</span>) A == <span class="number">2</span>, X &lt;= <span class="number">1</span>, 记为T3, <span class="built_in">F4</span></span><br><span class="line">(<span class="number">7</span>) A != <span class="number">2</span>, X &gt;  <span class="number">1</span>, 记为<span class="built_in">F3</span>, T4</span><br><span class="line">(<span class="number">8</span>) A != <span class="number">2</span>, X &lt;= <span class="number">1</span>, 记为<span class="built_in">F3</span>, <span class="built_in">F4</span></span><br></pre></td></tr></table></figure></div>
<p>太懒了，图略</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">用例编号</th>
<th style="text-align: center;">ABX</th>
<th style="text-align: center;">覆盖组合号</th>
<th style="text-align: center;">路径</th>
<th style="text-align: center;">覆盖条件</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">203</td>
<td style="text-align: center;">(1)(5)</td>
<td style="text-align: center;">ace</td>
<td style="text-align: center;">T1 T2 T3 T4</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">211</td>
<td style="text-align: center;">(2)(6)</td>
<td style="text-align: center;">abe</td>
<td style="text-align: center;">T1 F2 T3 F4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">103</td>
<td style="text-align: center;">(3)(7)</td>
<td style="text-align: center;">abe</td>
<td style="text-align: center;">F1 T2 F3 T4</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">111</td>
<td style="text-align: center;">(4)(8)</td>
<td style="text-align: center;">abd</td>
<td style="text-align: center;">F1 F2 F3 F4</td>
</tr>
</tbody>
</table>
<p>解释：主要关注覆盖组合号和覆盖条件，要求如下：</p>
<ul>
<li>覆盖组合号：每条测试用例必须包含<strong>第一个分支和第二个分支的一种不同组合</strong></li>
<li>覆盖条件：<strong>T1 - T4, F1 - F4</strong>的所有条件都需要覆盖</li>
</ul>
<blockquote>
<p>漏掉了路径acd，并不是完备的测试</p>
</blockquote>
<h3 id="路径覆盖">路径覆盖：</h3>
<p>覆盖程序中<strong>所有可能的路径</strong>(理想的测试程度)</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">ace</span> -&gt;</span> L1</span><br><span class="line"><span class="function"><span class="title">abc</span> -&gt;</span> L2</span><br><span class="line"><span class="function"><span class="title">abe</span> -&gt;</span> L3</span><br><span class="line"><span class="function"><span class="title">acd</span> -&gt;</span> L4</span><br></pre></td></tr></table></figure></div>
<p><img src="/2022/05/08/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/Inkedimage-20220317171842003_LI-1651987244264.jpg" alt="Inkedimage-20220317171842003_LI" style="zoom:67%;"></p>
<p><strong>解释</strong>：组合数学原理，第一个分支有两个选择，第二个分支有两个选择，故共有2
<span class="math inline">\(\times\)</span> 2 = 4种选择</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">用例编号</th>
<th style="text-align: center;">ABX</th>
<th style="text-align: center;">覆盖路径</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">203</td>
<td style="text-align: center;">ace(L1)</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">101</td>
<td style="text-align: center;">abd(L2)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">211</td>
<td style="text-align: center;">abe(L3)</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">301</td>
<td style="text-align: center;">acd(L4)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>路径测试虽然完备，但是当项目达到一定量级时，独立路径的数量会非常大</p>
</blockquote>
<h3 id="基本路径测试方法">基本路径测试方法</h3>
<h5 id="四个步骤">四个步骤：</h5>
<ol type="1">
<li><p>画出程序的<strong>控制流图</strong></p></li>
<li><p>计算程序的<strong>环形复杂度</strong></p>
<ul>
<li><p>一种为程序逻辑复杂度提供<strong>定量尺度</strong>的软件度量</p></li>
<li><p>提供程序基本集的独立路径数量</p></li>
<li><p><strong>计算方法</strong>：<span class="math inline">\(V = E - N
+ 2\)</span>(<span class="math inline">\(E\)</span>是控制流图中边的数量，<span class="math inline">\(N\)</span>是节点数量)</p>
<p>​ <span class="math inline">\(V = P + 1\)</span>(<span class="math inline">\(P\)</span>是控制流图中<strong>判定节点</strong>的数量)</p></li>
</ul></li>
<li><p>导出基本路径集，<strong>确定程序的独立路径</strong></p>
<blockquote>
<p>独立路径：和其他的独立路径相比，<strong>至少引入一个新处理语句或一个新判断的程序通路</strong></p>
</blockquote></li>
<li><p>根据独立路径，<strong>设计测试用例</strong>的输入数据和预期输出</p></li>
</ol>
<h3 id="最少测试用例数计算">最少测试用例数计算</h3>
<p><img src="/2022/05/08/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220317194219038.png" alt="image-20220317194219038" style="zoom:67%;"></p>
<p>对于嵌套型分支结构，若有<span class="math inline">\(n\)</span>个判定语句，需要<span class="math inline">\(n+1\)</span>个测试用例</p>
<p>对于连锁型分支结构，若有<span class="math inline">\(n\)</span>个判定语句，需要有<span class="math inline">\(n*m\)</span>个测试用例</p>
<h4 id="例子">例子</h4>
<blockquote>
<p>计算该程序的最少测试用例数</p>
</blockquote>
<figure>
<img src="/2022/05/08/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220508141945220.png" alt="image-20220508141945220">
<figcaption aria-hidden="true">image-20220508141945220</figcaption>
</figure>
<blockquote>
<p>将程序分解，可分为4个大的连锁分支结构</p>
</blockquote>
<p><img src="/2022/05/08/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220508142428384.png" alt="image-20220508142428384" style="zoom:80%;"></p>
<ul>
<li><strong>1</strong>：<span class="math inline">\(n\)</span> + 1 = 1 +
1 = 2</li>
</ul>
<p><img src="/2022/05/08/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220508142455731.png" alt="image-20220508142455731" style="zoom:80%;"></p>
<ul>
<li><p><strong>2 - 8</strong>：可以分为2和3 - 8</p>
<ul>
<li><p>这里可以将3 - 8分解为两个连锁分支结构，其中</p>
<ul>
<li><p>3 - 6：<span class="math inline">\(n\)</span> + 1 = 4 + 1 =
5</p></li>
<li><p>7 - 8：<span class="math inline">\(n\)</span> + 1 = 2 + 1 =
3</p></li>
<li><p>故3 - 8的总用例数为3 <span class="math inline">\(\times\)</span>
5 = 15</p></li>
</ul></li>
<li><p>2 - 8：<span class="math inline">\(n\)</span> + 1 = 15 + 1 =
16</p></li>
</ul></li>
</ul>
<p><img src="/2022/05/08/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220508142505675.png" alt="image-20220508142505675" style="zoom:80%;"></p>
<ul>
<li><strong>9 - 10</strong>：<span class="math inline">\(n\)</span> + 1
= 2 + 1 = 3</li>
</ul>
<p><img src="/2022/05/08/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220508142513887.png" alt="image-20220508142513887" style="zoom:80%;"></p>
<ul>
<li><strong>11 - 12</strong>：<span class="math inline">\(n\)</span> + 1
= 2 + 1 = 3</li>
</ul>
<blockquote>
<p>故总测试用例数 = 2 <span class="math inline">\(\times\)</span> 16
<span class="math inline">\(\times\)</span> 3 <span class="math inline">\(\times\)</span> 3 = 288</p>
</blockquote>
]]></content>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>黑盒测试(功能性测试)</title>
    <url>/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="黑盒测试">黑盒测试</h2>
<p>又称功能性测试，将程序视为<strong>无法看见内部结构的黑盒子</strong>，通过可见的外部接口输入数据，经由程序处理后输出结果，看输出结果是否正确</p>
<figure>
<img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220501235602507.png" alt="image-20220501235602507">
<figcaption aria-hidden="true">image-20220501235602507</figcaption>
</figure>
<p>常见的黑盒测试方法有<u>等价类划分、边界值分析和因果图-决策表法</u>三种</p>
<h2 id="等价类划分">等价类划分</h2>
<h3 id="基本概念">基本概念</h3>
<ol type="1">
<li><strong>等价类</strong>：某个输入域的子集合，该子集合<u>揭露的程序错误都是等效的</u>，要么全部被正确处理，要么全部没被正确处理</li>
<li><strong>有效等价类</strong>：有意义的输入数据所构成的集合，用于检测程序是否实现了<u>预期的功能和性能</u></li>
<li><strong>无效等价类</strong>：没有意义的输入数据所构成的结合，用于处理程序<u>对于无效数据的处理能力</u></li>
</ol>
<h3 id="确立等价类的原则">确立等价类的原则</h3>
<ol type="1">
<li><p><strong>按照变量划分</strong>：先按照X划分，再按照Y划分，....，最后形成相应测试用例</p>
<blockquote>
<p>例：A <span class="math inline">\(\leq\)</span> x <span class="math inline">\(\leq\)</span> B，C <span class="math inline">\(\leq\)</span> y <span class="math inline">\(\leq\)</span> D</p>
<p>先按照x划分：</p>
<p>① 有效等价类为：A <span class="math inline">\(\leq\)</span> x <span class="math inline">\(\leq\)</span> B</p>
<p>② 无效等价类为：x &lt; A 和 B &lt; x(两个)</p>
<p>再按照y划分：</p>
<p>① 有效等价类为：C <span class="math inline">\(\leq\)</span> y <span class="math inline">\(\leq\)</span> D</p>
<p>② 无效等价类为：y &lt; C 和 D &lt; y(两个)</p>
</blockquote></li>
<li><p><strong>规定了取值范围</strong> <span class="math inline">\(\rightarrow\)</span>
确立<u>一个有效等价类</u>和<u>两个无效等价类</u></p>
<blockquote>
<p>例：数据范围是1~50</p>
<p>① 有效等价类为 <span class="math inline">\(\geq 1\)</span> &amp;&amp;
$ $</p>
<p>② 无效等价类为 <span class="math inline">\(&lt; 1\)</span> &amp;&amp;
<span class="math inline">\(&gt; 50\)</span></p>
</blockquote></li>
<li><p><strong>输入一个布尔量</strong> <span class="math inline">\(\rightarrow\)</span>
确立<u>一个有效等价类</u>和<u>一个无效等价类</u></p></li>
<li><p><strong>输入一组枚举值</strong> <span class="math inline">\(\rightarrow\)</span>
每个枚举值确立<u>一个有效等价类</u>，剩余值<u>共同确立无效等价类</u></p>
<blockquote>
<p>例：程序输入枚举类型 x = {1, 3, 7, 15}</p>
<p>① 有效等价类为 x = 1,x = 3, x = 7, x = 15</p>
<p>② 无效等价类为 x <span class="math inline">\(\ne\)</span> 1, 3, 7,
15</p>
</blockquote></li>
<li><p><strong>规定数据的规则</strong> <span class="math inline">\(\rightarrow\)</span>
确立<u>一个有效等价类</u>(遵守规则的数据)和<u>若干无效等价类</u></p>
<blockquote>
<p>例：测试密码域，要求密码必须是数字或字母</p>
<p>① 有效等价类为“密码是数字和字母的组合”</p>
<p>② 无效等价类为“密码包括中文，密码包括其他符号”等</p>
</blockquote></li>
</ol>
<h3 id="用例设计">用例设计</h3>
<ol type="1">
<li><p>为每个等价类分别规定一个唯一的编号</p></li>
<li><p>设计一个新的测试用例，<strong>能够尽量覆盖尚未覆盖的有效等价类</strong></p></li>
<li><p>设计一个新的测试用例，<strong>使它仅覆盖一个尚未覆盖的无效等价类</strong></p>
<blockquote>
<p>对于顺序是132还是123的说明：</p>
<p>①
123是先确认功能，后验证功能的正确性，即先确保需求没有遗失，后确认需求是否正确完成。一般是在客户验收阶段，即beta测试</p>
<p>②
132是先找功能是否错误，后确认需求是否满足。一般在系统内部测试阶段，即alpha测试阶段。</p>
</blockquote></li>
</ol>
<h3 id="举例以输入变量确认">举例(以输入变量确认)</h3>
<h4 id="题面">题面</h4>
<p>某保险公司承担人寿保险，该公司保费计算方式为：**保费=投保额*保险率**，保险率依点数不同而有别，10点以上（含10点）费率为0.6%，10点以下费率为0.1%</p>
<p>点数的计算是年龄、性别、婚姻、抚养人数所得的点数的总和</p>
<p>输入：年龄、性别、婚姻、抚养人数</p>
<p>输出：保险率</p>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220502155955725.png" alt="image-20220502155955725" style="zoom:80%;"></p>
<h4 id="第一步输入和输出变量确认">第一步：输入和输出变量确认</h4>
<p>输入：年龄、性别、婚姻、抚养人数</p>
<p>输出：保险率</p>
<p>等价类划分原则：<strong>按照输入变量来确认等价类</strong></p>
<h4 id="第二步等价类划分">第二步：等价类划分</h4>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220502160343829.png" alt="image-20220502160343829" style="zoom: 80%;"></p>
<h4 id="第三步设计测试用例">第三步：设计测试用例</h4>
<ol type="1">
<li><p>设计测试用例，尽可能的覆盖尚未覆盖的有效等价类</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>1</strong></th>
<th style="text-align: center;"><strong>8</strong></th>
<th style="text-align: center;"><strong>10</strong></th>
<th style="text-align: center;"><strong>12</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>2</strong></td>
<td style="text-align: center;"><strong>9</strong></td>
<td style="text-align: center;"><strong>11</strong></td>
<td style="text-align: center;"><strong>13</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>3</strong></td>
<td style="text-align: center;"><strong>8</strong></td>
<td style="text-align: center;"><strong>10</strong></td>
<td style="text-align: center;"><strong>14</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>3</strong></td>
<td style="text-align: center;"><strong>9</strong></td>
<td style="text-align: center;"><strong>10</strong></td>
<td style="text-align: center;"><strong>15</strong></td>
</tr>
</tbody>
</table></li>
<li><p>设计测试用俐，使得每一个新设计的测试用例只包含一个无效等价类</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>4</strong></th>
<th style="text-align: center;"><strong>8</strong></th>
<th style="text-align: center;"><strong>10</strong></th>
<th style="text-align: center;"><strong>12</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>5</strong></td>
<td style="text-align: center;"><strong>9</strong></td>
<td style="text-align: center;"><strong>11</strong></td>
<td style="text-align: center;"><strong>13</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>6</strong></td>
<td style="text-align: center;"><strong>8</strong></td>
<td style="text-align: center;"><strong>10</strong></td>
<td style="text-align: center;"><strong>14</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>7</strong></td>
<td style="text-align: center;"><strong>8</strong></td>
<td style="text-align: center;"><strong>10</strong></td>
<td style="text-align: center;"><strong>14</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>1</strong></td>
<td style="text-align: center;"><strong>8</strong></td>
<td style="text-align: center;"><strong>10</strong></td>
<td style="text-align: center;"><strong>16</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>2</strong></td>
<td style="text-align: center;"><strong>9</strong></td>
<td style="text-align: center;"><strong>11</strong></td>
<td style="text-align: center;"><strong>17</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>3</strong></td>
<td style="text-align: center;"><strong>8</strong></td>
<td style="text-align: center;"><strong>10</strong></td>
<td style="text-align: center;"><strong>18</strong></td>
</tr>
</tbody>
</table></li>
</ol>
<h4 id="第四步选取测试用例">第四步：选取测试用例</h4>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220502160830077.png" style="zoom:80%;"></p>
<h3 id="举例以输出变量确认">举例(以输出变量确认)</h3>
<h4 id="题面-1">题面</h4>
<p>输入3个整数变量a, b,
c，a、b和c均在1—100之间，a、b和c任意2个加起来大于第三个，<u>测试是否为等边三角形、等腰三角形、一般三角形和非三角形</u>。</p>
<h4 id="第一步输入和输出变量确认-1">第一步：输入和输出变量确认</h4>
<p>输入：三个变量(a, b, c)，a、b和c都在1到100之间。</p>
<p>输出：是否为三角形或各类三角形</p>
<blockquote>
<p>输入域情况复杂，很难清晰界定，输出域则较为清晰</p>
</blockquote>
<p>等价类划分原则：<strong>按照输出变量来确认等价类</strong></p>
<h4 id="第二步划分等价类">第二步：划分等价类</h4>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220502161627300.png" alt="image-20220502161627300" style="zoom:80%;"></p>
<h3 id="总结">总结</h3>
<ol type="1">
<li><p>什么时候按照输入域划分，什么时候按照输出域划分？</p>
<p>答：输入变量有清晰的规则，且变量间没有关联关系的情况下按照输入域划分；反之则按照输出域设计测试用例。</p></li>
<li><p>什么情况下使用等价类划分的方法？</p>
<p>答：一般在录入、算法、报表模块使用，因为这些输入变量间没有直接关系。</p></li>
</ol>
<hr>
<h2 id="边界值分析">边界值分析</h2>
<h3 id="基本概念-1">基本概念</h3>
<p>边界值分析就是<u>对输入或输出的边界值进行测试</u>的黑盒测试方法，是等价类划分方法的一种补充，<u>测试用例来自等价类的边界</u></p>
<blockquote>
<p>边界值指的是有效和无效等价类的边界的两个值，两个值逻辑意义上相连，但一个属于有效输入，一个属于无效输入</p>
</blockquote>
<ol type="1">
<li><p>数据范围是<span class="math inline">\(1 \leqslant x \leqslant
50\)</span></p>
<p>边界值取为：<span class="math inline">\(1，50，0，51\)</span></p></li>
<li><p>数据范围是<span class="math inline">\(1 &lt; x &lt;
50\)</span></p>
<p>边界值取为：<span class="math inline">\(1，50，2，49\)</span></p></li>
</ol>
<h3 id="等价类划分和边界值分析的区别">等价类划分和边界值分析的区别</h3>
<blockquote>
<p>例子：测试sqrt()函数</p>
<p>输入：实数</p>
<p>输出：实数</p>
<p>规则：对于输入的值<span class="math inline">\(x\)</span>，当 <span class="math inline">\(x \geq 0\)</span> 时，返回 <span class="math inline">\(\sqrt{x}\)</span>，当 <span class="math inline">\(x &lt; 0\)</span> 时，显示错误信息</p>
<p>一、等价类划分</p>
<p>① 有效等价类： <span class="math inline">\(x \geq 0\)</span> |
无效等价类： <span class="math inline">\(x &lt; 0\)</span></p>
<p>② 测试用例：输入4，输出2 | 输入-10，输出错误信息</p>
<p>二、边界值分析</p>
<p>① 划分 <span class="math inline">\(x \geq 0\)</span>
的边界为0和最大正实数，划分 <span class="math inline">\(x &lt;
0\)</span> 为最小负实数和0</p>
<p>②
测试用例：输入最小负实数、绝对值很小的负数、0、绝对值很小的正数、最大正实数</p>
</blockquote>
<h3 id="举例">举例</h3>
<h4 id="题面-2">题面</h4>
<p>假设商店商品价格[X]皆不大于100元(整数)，若顾客买一件商品，付款[Y]在100元内，求找给顾客的最少货币张数？</p>
<p>货币面值：50元[R50]、20元[R20]、10元[R10]、5元[R5]、2元[R2]、1元[R1]</p>
<h4 id="第一步分析输入">第一步：分析输入</h4>
<p><span class="math inline">\(X &gt; 100\)</span></p>
<p><span class="math inline">\(0 &lt; X \leq 100\)</span></p>
<p><span class="math inline">\(X \leq 0\)</span></p>
<p><span class="math inline">\(Y &gt; 100\)</span></p>
<p><span class="math inline">\(X \leq Y \leq 100\)</span></p>
<p><span class="math inline">\(Y &lt; X\)</span></p>
<h4 id="第二步分析输出">第二步：分析输出</h4>
<p><span class="math inline">\(0 \leq R50 \leq 1\)</span></p>
<p><span class="math inline">\(0 \leq R20 \leq 2\)</span></p>
<p><span class="math inline">\(0 \leq R10 \leq 1\)</span></p>
<p><span class="math inline">\(0 \leq R5 \leq 1\)</span></p>
<p><span class="math inline">\(0 \leq R2 \leq 2\)</span></p>
<p><span class="math inline">\(0 \leq R1 \leq 1\)</span></p>
<h4 id="第三步分析边界">第三步：分析边界</h4>
<p>无效边界：</p>
<p><span class="math inline">\(X &gt; 100\)</span></p>
<p><span class="math inline">\(X \leq 0\)</span></p>
<p><span class="math inline">\(Y &gt; 100\)</span></p>
<p><span class="math inline">\(Y &lt; X\)</span></p>
<p>有效边界：</p>
<p>设找部分钱后剩余的金额为<span class="math inline">\(S\)</span>（初始<span class="math inline">\(S=Y\)</span>）</p>
<p><span class="math inline">\(S \geq 50 找R50\)</span></p>
<p><span class="math inline">\(20 \leq S &lt; 50 找R20\)</span></p>
<p><span class="math inline">\(10 \leq S &lt; 20 找R10\)</span></p>
<p><span class="math inline">\(5 \leq S &lt; 10 找R5\)</span></p>
<p><span class="math inline">\(2 \leq S &lt; 5 找R2\)</span></p>
<p><span class="math inline">\(1 \leq S &lt; 2 找R1\)</span></p>
<h4 id="第四步分析情形">第四步：分析情形</h4>
<p>无效情形：</p>
<p><span class="math inline">\(X &gt; 100\)</span> 错误</p>
<p><span class="math inline">\(X \leq 0\)</span> 错误</p>
<p><span class="math inline">\(0 &lt; X \leq 100, Y &gt; 100\)</span>
错误</p>
<p><span class="math inline">\(0 &lt; X \leq 100, Y &lt; X\)</span>
错误</p>
<p>有效情形：</p>
<p><span class="math inline">\(S =
51,50,49,20,19,10,9,5,4,2,1,0\)</span></p>
<h4 id="第五步设计测试用例">第五步：设计测试用例</h4>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220502165040522.png" alt="image-20220502165040522" style="zoom:80%;"></p>
<h3 id="总结-1">总结</h3>
<ol type="1">
<li><p>对于一个含有<span class="math inline">\(n\)</span>个变量的程序，采用边界值分析法会产生<span class="math inline">\(4n+1\)</span>个测试用例</p>
<blockquote>
<p>对于二元函数<span class="math inline">\(f(x,y)\)</span>，其中 <span class="math inline">\(x \in [1,12]\)</span>，<span class="math inline">\(y \in [1,31]\)</span></p>
<p>采用边界值分析法设计的测试用例是：</p>
<p>{&lt;1,15&gt;,&lt;2,15&gt;,&lt;11,15&gt;,&lt;12,15&gt;,&lt;6,15&gt;,&lt;6,1&gt;,&lt;6,2&gt;,&lt;6,30&gt;,&lt;6,31&gt;}</p>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220502165855510.png" alt="image-20220502165855510" style="zoom:80%;"></p>
</blockquote></li>
<li><p>而如果是健壮性测试用例，需要<span class="math inline">\(6n+1\)</span>个测试用例</p>
<blockquote>
<p>对于二元函数<span class="math inline">\(f(x,y)\)</span>，其中 <span class="math inline">\(x \in [1,12]\)</span>，<span class="math inline">\(y \in [1,31]\)</span></p>
<p>采用边界值分析法设计的测试用例是：</p>
<p>{&lt;0,15&gt;&lt;1,15&gt;,&lt;2,15&gt;,&lt;11,15&gt;,&lt;12,15&gt;,&lt;13,15&gt;,&lt;6,15&gt;,&lt;6,0&gt;&lt;6,1&gt;,&lt;6,2&gt;,&lt;6,30&gt;,&lt;6,31&gt;,&lt;6,32&gt;}</p>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220502170149026.png" alt="image-20220502170149026" style="zoom:80%;"></p>
</blockquote></li>
<li><p><strong>等价类划分和边界值分析都没有考虑到变量的相关性</strong></p></li>
</ol>
<h2 id="因果图与决策表法">因果图与决策表法</h2>
<h3 id="基本概念-2">基本概念</h3>
<p>一些程序的功能可以用判定表(决策表)的形式来表示，并根据输入条件的组合情况规定相应的操作。而因果图法是<u>利用图解法分析输入的各种组合情况，从而设计测试用例的方法</u>。</p>
<p>基本步骤：</p>
<ol type="1">
<li>根据程序规格说明书，<u>分析并确定因果，画出因果图</u></li>
<li>将得到的<u>因果图转换为判定表</u></li>
<li>为判定表中的每一列所表示的情况<u>设计一个测试用例</u></li>
</ol>
<h3 id="判定表">判定表</h3>
<h5 id="四个组成部分">四个组成部分：</h5>
<ol type="1">
<li><p><strong>条件桩</strong>：列出问题的所有条件</p></li>
<li><p><strong>条件项</strong>：针对条件桩给出的条件列出所有可能的取值</p></li>
<li><p><strong>动作桩</strong>：列出问题规定的可能采取的操作</p></li>
<li><p><strong>动作项</strong>：指出在条件项的各组取值情况下应采取的动作</p>
<table>
<thead>
<tr class="header">
<th><strong>条件桩</strong></th>
<th><strong>条件项</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>动作桩</strong></td>
<td><strong>动作项</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p>贯穿条件项和动作项的一列就是<strong>一条规则</strong>，下面是例子：</p>
</blockquote>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220508113729297.png" alt="image-20220508113729297" style="zoom:80%;"></p></li>
</ol>
<h3 id="因果图">因果图</h3>
<h5 id="种因果关系符号">4种因果关系符号</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">符号</th>
<th style="text-align: center;">意义(0和1代表False和True)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">恒等</td>
<td style="text-align: center;"><code>c1 === e1;</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">非</td>
<td style="text-align: center;"><code>if(c1 == 1) e1 = 0; else e1 = 1;</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">或</td>
<td style="text-align: center;"><code>if(c1 || c2 || c3 == 1) e1 = 1; else e1 = 0</code>;</td>
</tr>
<tr class="even">
<td style="text-align: center;">与</td>
<td style="text-align: center;"><code>if(c1 &amp;&amp; c2 == 2) e1 = 1; else e1 = 0;</code></td>
</tr>
</tbody>
</table>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220508114644203.png" alt="image-20220508114644203" style="zoom:80%;"></p>
<h5 id="种因果图约束">5种因果图约束</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">约束</th>
<th style="text-align: center;">意义(0和1代表False和True)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">异</td>
<td style="text-align: center;">不能同时等于1</td>
</tr>
<tr class="even">
<td style="text-align: center;">或</td>
<td style="text-align: center;">不能同时等于0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">唯一</td>
<td style="text-align: center;">有且只有一个等于1</td>
</tr>
<tr class="even">
<td style="text-align: center;">要求</td>
<td style="text-align: center;">输入a是1时，b也必须是1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">强制</td>
<td style="text-align: center;">结果a为1，b强制为0</td>
</tr>
</tbody>
</table>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220508115125679.png" alt="image-20220508115125679" style="zoom:67%;"></p>
<h5 id="案例">案例</h5>
<p><strong>第一列</strong>字符必须是<strong>#或</strong>*，<strong>第二列</strong>字符必须是<strong>一个数字</strong>，在此情况下进行文件的修改。但如果第一列字符不正确，则给出<strong>信息L</strong>；如果第二列字符不是数字，则给出<strong>信息M</strong>。</p>
<p>解题步骤：</p>
<ol type="1">
<li>分析程序的规格说明，<strong>列出原因和结果</strong>。</li>
<li>找出原因与结果之间的因果关系、原因与原因之间的约束关系，<strong>画出因果图</strong>。</li>
<li><strong>将因果图转换成决策表</strong>。</li>
<li>根据(3)中的决策表，<strong>设计测试用例</strong>的输入数据和预期输出。</li>
</ol>
<p>原因：</p>
<ul>
<li>c1：第一列字符是#</li>
<li>c2：第一列字符是*</li>
<li>c3：第二列字符是一个数字</li>
<li>10：第一列字符是#或*</li>
</ul>
<p>结果：</p>
<ul>
<li>e1：给出信息L</li>
<li>e2：修改文件</li>
<li>e3：给出信息M</li>
</ul>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220508120326033.png" alt="image-20220508120326033" style="zoom:80%;"></p>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220508120344332.png" alt="image-20220508120344332" style="zoom:80%;"></p>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220508120355562.png" alt="image-20220508120355562" style="zoom:80%;"></p>
]]></content>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
</search>
