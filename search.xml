<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式</title>
    <url>/2022/04/29/Design%20Patterns/</url>
    <content><![CDATA[<blockquote>
<h4 id="singleton单例模式">Singleton：单例模式</h4>
<p>确保类自身(类自己实现)<strong>只有一个实例</strong>，并<strong>提供</strong>它的<strong>全局访问点</strong></p>
<p>如何保证类只有一个实例？
<strong>使用类本身来负责，而不是用户负责</strong></p>
<p>应用：注册表、ID生成器、身份证、频繁访问数据库和文件对象、连接池、配置对象</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 静态私有成员变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"><span class="comment">// 2. 构造函数设置成private防止类外调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">	singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 共有的动态工厂方法</span></span><br><span class="line"><span class="comment">// 3.1 Eager Singleton: 孤子类在自己被加载时就实例化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singelton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.2 Lazy Singleton: 需要使用时再实例化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singelton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(instance == <span class="literal">null</span>)</span><br><span class="line">  	instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="type">Singleton</span> <span class="variable">obj</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lazy Singleton的双加锁机制，防止并发错误</span></span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">	lock(syncRoot); <span class="comment">// 先加锁</span></span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">  		instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重加锁的单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLockSingleton</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.指向自身实例的私有静态引用</span></span><br><span class="line"><span class="comment">     * volatile: 被volatile修饰的变量不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，禁止指令重排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">DoubleLockSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.私有的构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DoubleLockSingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.以自身实例为返回值的静态的共有方法</span></span><br><span class="line"><span class="comment">     * synchronized: 同步锁，保证同步区内的操作具有原子性、可见性、有序性</span></span><br><span class="line"><span class="comment">     * 原子性: 一个操作或多个操作，要么全部执行，要么全部不执行</span></span><br><span class="line"><span class="comment">     * 可见性: 多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的</span></span><br><span class="line"><span class="comment">     * 有序性: 有序性值程序执行的顺序按照代码先后执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DoubleLockSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 开启同步区</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleLockSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">DoubleLockSingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有静态内部类，避免多线程同步问题，还能反序列化创建新的对象</span></span><br><span class="line"><span class="comment"> * 1. 不提供构造函数杜绝用户产生该类实例</span></span><br><span class="line"><span class="comment"> * 2. 全部实例都是public static final，不允许变动却可以让用户使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="comment">// 使用final关键字保证只能实例化一次</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  	<span class="comment">// 通过调用内部类的getInstance方法保证单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式的变形：对象数量有限的多例模式</span></span><br><span class="line"><span class="comment"> * 核心思想：</span></span><br><span class="line"><span class="comment"> * 1.构造器私有化，外部不能随意new该对象</span></span><br><span class="line"><span class="comment"> * 2.对外提供获得修改对象的方法</span></span><br><span class="line"><span class="comment"> * 3.使用一个类变量记录允许的最大对象数量</span></span><br><span class="line"><span class="comment"> * 4.使用一个类变量记录当前对象的序号</span></span><br><span class="line"><span class="comment"> * 5.使用一个list记录所有产生的对象，每次使用时，都从list中获取对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LimitMultigrainMode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxNumsOfObject</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;LimitMultigrainMode&gt; limitMultigrainModeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;LimitMultigrainMode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">curNumsOfObject</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 事先实例化出maxNumsOfObject个对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxNumsOfObject; i++) &#123;</span><br><span class="line">            limitMultigrainModeList.add(<span class="keyword">new</span> <span class="title class_">LimitMultigrainMode</span>(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;个实例&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LimitMultigrainMode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LimitMultigrainMode</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        nameList.add(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LimitMultigrainMode <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 随机获取1~maxNumsOfObject个实例中的随机一个</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        curNumsOfObject = random.nextInt(maxNumsOfObject);</span><br><span class="line">        <span class="keyword">return</span> limitMultigrainModeList.get(curNumsOfObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(nameList.get(curNumsOfObject));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>三个要点：</p>
<ol type="1">
<li>某个类只能有一个实例</li>
<li>它必须自行创建这个实例</li>
<li>它必须自行向整个系统提供这个实例</li>
</ol>
<p>优点：</p>
<ol type="1">
<li>提供对<strong>唯一</strong>实例的<strong>受控</strong>访问</li>
<li>节约系统资源</li>
<li>允许<strong>可变数目</strong>的实例</li>
</ol>
<p>缺点：</p>
<ol type="1">
<li><strong>没有抽象层</strong>，扩展性差</li>
<li><strong>类职责太重</strong>，既充当工厂又充当产品角色</li>
<li><strong>滥用单例的负面问题</strong>，如共享连接池对象的程序过多而出现连接池溢出</li>
<li>多个类加载器可能导致单例模式失效</li>
</ol>
</blockquote>
<hr>
<blockquote>
<h4 id="adapter适配器模式">Adapter：适配器模式</h4>
<p>不能复用的原因可能仅仅是因为接口不匹配</p>
<p>适配器将现有的接口转化为客户类期望的接口，保证对现有类的重用</p>
<p><img src="/2022/04/29/Design%20Patterns/image-20220412111148990.png" alt="image-20220412111148990" style="zoom:80%;"></p>
<p>JDBC：适配器软件，提供Java语言程序和数据库的连接服务</p>
<p>客户类并不直接调用适配器类</p>
<p>应用：系统需要使用现有类，但类的接口不符合系统的需要，第三方组件，但组件的接口不一致(远程调用)</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的适配器模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">     		specificRequest();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的适配器模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"> 	<span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">     		<span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">     		adaptee.specificRequest();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 双向适配器</span></span><br><span class="line"><span class="comment"> * 1.编写需要双向适配的两个类接口</span></span><br><span class="line"><span class="comment"> * 2.编写两个类接口的实现类</span></span><br><span class="line"><span class="comment"> * 3.编写双向适配器，在适配器中重写接口的实现部分方法(需要相互适配的方法)</span></span><br><span class="line"><span class="comment"> * 4.使用适配器的构造函数实例化对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下有两个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catLooks</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dogLooks</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dogBark</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下有两个接口的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ICatImpl</span> <span class="keyword">implements</span> <span class="title class_">ICat</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catLooks</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我像一只猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我能抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDogImpl</span> <span class="keyword">implements</span> <span class="title class_">IDog</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dogLooks</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我像一条狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dogBark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会犬吠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 双向适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">implements</span> <span class="title class_">ICat</span>, IDog&#123;</span><br><span class="line">    <span class="type">ICat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">IDog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 两个接口的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(ICat cat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(IDog dog)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catLooks</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一只猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 猫学会犬吠</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        dog.dogBark();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dogLooks</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一条狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 狗学会抓老鼠</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dogBark</span><span class="params">()</span> &#123;</span><br><span class="line">        cat.catchMouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 把狗适配为猫</span></span><br><span class="line">        <span class="type">ICat</span> <span class="variable">fakeCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>(<span class="keyword">new</span> <span class="title class_">IDogImpl</span>());</span><br><span class="line">        fakeCat.catLooks();</span><br><span class="line">        fakeCat.catchMouse();</span><br><span class="line">        <span class="comment">// 把猫适配为狗</span></span><br><span class="line">        <span class="type">IDog</span> <span class="variable">fakeDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>(<span class="keyword">new</span> <span class="title class_">ICatImpl</span>());</span><br><span class="line">        fakeDog.dogLooks();</span><br><span class="line">        fakeDog.dogBark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>优点：</p>
<ol type="1">
<li>将目标类和适配器类<strong>解耦合</strong>，<strong>无需修改原有代码</strong></li>
<li>将具体的实现封装在适配器类中，提高了适配器的复用性</li>
<li><strong>灵活性和扩展性都非常好</strong>，使用配置文件可以方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，<strong>符合开闭原则</strong></li>
</ol>
<p>缺点：</p>
<ol type="1">
<li>对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配器类</li>
</ol>
</blockquote>
<hr>
<blockquote>
<h4 id="template-method模板模式">Template Method：模板模式</h4>
<p>不改变算法结构的前提下重定义某些特定步骤<strong>（本质：控制子类的扩展）</strong></p>
<p><span class="math inline">\(Template Method = \sum (Primitive
Methods)\)</span></p>
<p>模板：确保父类控制处理流程的逻辑顺序，需要保证<strong>模板的严肃性</strong>(final)</p>
<p>应用：框架设计</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight /scss"><table><tr><td class="code"><pre><span class="line">AbstractClass &#123;</span><br><span class="line">	<span class="built_in">method1</span>()</span><br><span class="line">	<span class="built_in">method2</span>()</span><br><span class="line">	<span class="built_in">method3</span>()</span><br><span class="line">	<span class="built_in">templateMethod</span>() <span class="comment">// 规定method1-3的处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="/2022/04/29/Design%20Patterns/image-20220419103112374.png" alt="image-20220419103112374" style="zoom:80%;"></p>
<p><strong>好莱坞原则</strong>：子类不显式调用父类的方法，而是通过覆盖父类的方法实现业务逻辑，父类控制对子类的调用</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractDisplay</span> &#123;</span><br><span class="line">   <span class="comment">// 三个抽象方法，子类可重定义</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>; </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">// 模板方法，规定执行顺序，必须用final修饰</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">       open();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           print();</span><br><span class="line">       &#125;</span><br><span class="line">       close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>钩子方法(Hook
Method)</strong>：实现子类对父类行为的反向控制</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">template</span><span class="params">()</span> &#123;</span><br><span class="line">	open();</span><br><span class="line">    display();</span><br><span class="line">       <span class="keyword">if</span>(isPrint()) &#123;</span><br><span class="line">       	print();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 钩子方法，子类可重写，用于控制print()方法是否实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPrint</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<p>优点：形式化定义算法，子类实现细节，是一种<strong>代码复用</strong>技术，构造一种<strong>反向控制</strong>结构，符合<strong>开闭原则</strong></p>
<p>缺点：每个不同实现都要定义一个子类，导致类个数增加，系统庞大，但符合<strong>单一职责原则</strong>，<strong>增强内聚性</strong></p>
<p>启发：逻辑可共享(父类和子类共享逻辑)，向上转型(子类视同父类)，父类和子类的协调，好莱坞原则</p>
</blockquote>
<hr>
<blockquote>
<h4 id="inversion-of-controlioc控制反转">Inversion of
Control(Ioc)：控制反转</h4>
<p><strong>Ioc是一种设计原则而非设计模式</strong>，设计模式和Ioc的关系：</p>
<p><img src="/2022/04/29/Design%20Patterns/image-20220420093403816.png" alt="image-20220420093403816" style="zoom:80%;"></p>
<p>用于在面向对象设计中反转不同类型的控件实现<strong>松散耦合</strong>的设计(为什么需要松散耦合的设计?)</p>
<ul>
<li>一个类的变动不会迫使另一个类的变动，因此增强了整个应用的可维护性和可扩展性</li>
</ul>
<p>control是指除了其主要职责之外的任何其他职责，包括：</p>
<ul>
<li>对应用程序流程的控制</li>
<li>对象创建或依赖对象创建和绑定流程的控制</li>
</ul>
<p>举例：自己开车到工作单位 <span class="math inline">\(\rightarrow\)</span> 雇了一个出租车司机到工作单位
(从自己到出租车司机的控制反转)</p>
<p><img src="/2022/04/29/Design%20Patterns/image-20220420085422288.png" alt="image-20220420085422288" style="zoom:80%;"></p>
<p><strong>程序流程的控制</strong>：</p>
<p>举例：使用Main函数控制程序流程 <span class="math inline">\(\rightarrow\)</span> 使用GUI控制程序流程</p>
<p><strong>控制从属对象的创建：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非Ioc写法</span></span><br><span class="line"><span class="comment"> * A调用b的someMethod方法实现Task1方法，A不能脱离B完成这个任务，故A依赖于B</span></span><br><span class="line"><span class="comment"> * 本质：A控制了B对象的创建和生命周期</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span> <span class="params">()</span> &#123;</span><br><span class="line">        b = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Task1</span><span class="params">()</span> &#123;</span><br><span class="line">        b.someMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// doing something..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ioc写法</span></span><br><span class="line"><span class="comment"> * 类A使用Factory来获得一个B的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        b = Factory.getObjectOfB();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Task1</span><span class="params">()</span> &#123;</span><br><span class="line">        b.someMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用工厂类来创建B实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> B <span class="title function_">GetObjectOfB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>以n层架构为例：</p>
<p><img src="/2022/04/29/Design%20Patterns/image-20220420092015357.png" alt="image-20220420092015357" style="zoom:80%;"></p>
<p>UI通过Service获取或存储数据，Service层依赖BusinessLogic对数据的存取规则，BusinessLogic依赖数据库</p>
<p>现在关注BusinessLogic和DataAccess：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此时DAO依赖于Mapper</span></span><br><span class="line"><span class="comment"> * 造成了CustomerBusinessLogic和DataAccess两个类紧耦合</span></span><br><span class="line"><span class="comment"> * 问题1：此时如果需要改变DataAccess(增加|删除方法)，CustomerBusinessLogic也需要随之改变</span></span><br><span class="line"><span class="comment"> * 问题2：如果用户数据来自于不同的数据库，则后续需要创建不同的Mapper类，DAO也需要随之改变</span></span><br><span class="line"><span class="comment"> * 问题3：如果需要对DataAccess重命名，则需要找到所有应用DataAccess的位置进行修改</span></span><br><span class="line"><span class="comment"> * 问题4：CustomerBusinessLogic依赖DataAccess创建，那么就无法进行独立测试(TDD)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerBusinessLogic</span> &#123;</span><br><span class="line">    DataAccess dataAccess;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerBusinessLogic</span><span class="params">()</span> &#123;</span><br><span class="line">        dataAccess = <span class="keyword">new</span> <span class="title class_">DataAccess</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataAccess.getCustomerName(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataAccess</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataAccess</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dummy Customer Name&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Ioc解决该问题</span></span><br><span class="line"><span class="comment">// 1. 创建一个返回DataAccess实例的Factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataAccessFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DataAccess <span class="title function_">getDataAccessObj</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataAccess</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.使用DataAccessFactory在CustomerBusiness创建DataAccess实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerBusinessLogic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerBusinessLogic</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">DataAccess</span> <span class="variable">dataAccess</span> <span class="operator">=</span> DataAccessFactory.getDataAccessObj();</span><br><span class="line">        <span class="keyword">return</span> dataAccess.getCustomerName(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="dependency-inversion-principledip依赖倒置原则">Dependency
Inversion Principle(DIP)：依赖倒置原则</h4>
<p>DIP是SOLID面向对象原则之一，定义为：</p>
<ul>
<li>高级模块不应该依赖低级模块，两者都应该依赖于抽象</li>
<li>抽象不应该依赖于具体实现，具体实现应该依赖于抽象</li>
</ul>
<p>对于上述实现了Ioc的代码，仍然存在一些问题：</p>
<ul>
<li>CustomerBusinessLogic类仍然聚合了DataAccess，仍然为紧耦合</li>
</ul>
<p>下面使用DIP得到更为松散耦合的结构：</p>
<ul>
<li>确定哪些是高级模块，哪些是低级模块，在例子中CustomerBusinessLogic依赖于DataAccess所以是高级模块，DataAccess则是低级模块，两者都应该依赖于抽象</li>
</ul>
<p>什么是抽象？不具体的就是抽象</p>
<ul>
<li>对于CustomerBusinessLogic和DataAccess都是具体类，我们<strong>可以创建它们的实例</strong>，<strong>但是我们不能创建抽象类的实例</strong></li>
<li>两者都依赖于抽象，即<strong>都依赖于接口或抽象类</strong></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象：用户数据存取接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICustomerDataAccess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低级模块：在CustomerDataAccess类中实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerDataAccess</span> <span class="keyword">implements</span> <span class="title class_">ICustomerDataAccess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerDataAccess</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dummy Customer Name&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变工厂类，使其返回接口而非具体的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataAccessFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ICustomerDataAccess <span class="title function_">getCustomerDataAccessObj</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomerDataAccess</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高级模块：改变CustomerBusinessLogic，使其使用接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerBusinessLogic</span> &#123;</span><br><span class="line">    ICustomerDataAccess iCustomerDataAccess;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerBusinessLogic</span><span class="params">()</span> &#123;</span><br><span class="line">        iCustomerDataAccess = DataAccessFactory.getCustomerDataAccessObj();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iCustomerDataAccess.getCustomerName(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>DIP的优点：CustomerBusinessLogic和DataAccess愈发松散耦合(因为CustomerBusinessLogic不依赖于具体类而是抽象接口)</p>
<h4 id="dependency-injectiondi依赖注入">Dependency
Injection(DI)：依赖注入</h4>
<p>Ioc和DIP存在的问题：在CustomerBusinessLogic类中使用了工厂，此时如果有ICustomerDataAccess的其他实现方式，同样需要修改CustomerBusinessLogic的源代码，而DI能够解决这一问题。</p>
<p><strong>DI是一种设计模式</strong>，使得类之间完全松散耦合，将创建和绑定依赖的对象移除类外</p>
<p>DI中涉及三种类：</p>
<ol type="1">
<li>客户端类(Client Class)：依赖于服务端类的类</li>
<li>服务端类(Service Class) ：给客户端提供服务的类</li>
<li>注射器类(Injector Class)：将服务端类注入客户端类的类</li>
</ol>
<p><img src="/2022/04/29/Design%20Patterns/image-20220420103203215.png" alt="image-20220420103203215" style="zoom:80%;"></p>
<p>三个类的关系如上图，可以发现注射剂创建了一个服务类实例，并且将该类注入客户类，这将创建服务类实例的职责从客户端中分离开来。</p>
<p><strong>依赖注入的类型：</strong></p>
<ul>
<li>构造函数注入：注射器通过客户类的构造函数提供服务</li>
<li>属性注入：提供给客户类公共属性</li>
<li>方法注入：客户类实现一个接口，注射器通过这个接口提供服务</li>
</ul>
<p>举例：使用CustomerService作为注射器类</p>
<p><strong>构造函数注入</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注射器类，创建CustomerDataAccess并将其注入到CustomerBusinessLoic中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerService</span> &#123;</span><br><span class="line">    CustomerBusinessLoic customerBusinessLoic;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerService</span><span class="params">()</span> &#123;</span><br><span class="line">        customerBusinessLogic = <span class="keyword">new</span> <span class="title class_">CustomerBusinessLogic</span>(<span class="keyword">new</span> <span class="title class_">CustomerDataAccess</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> customerBusinessLogic.processCustomerData(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用该类现在必须注入一个ICustomerDataAccess对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerBusinessLogic</span> &#123;</span><br><span class="line">    ICustomerDataAccess dataAccess;</span><br><span class="line">	<span class="comment">// 包含了一个具有ICustomerDataAccess类型参数的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerBusinessLogic</span><span class="params">(ICustomerDataAccess custDataAccess)</span> &#123;</span><br><span class="line">        dataAccess = custDataAccess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerBusinessLogic</span><span class="params">()</span> &#123;</span><br><span class="line">        dataAccess = <span class="keyword">new</span> <span class="title class_">CustomerDataAccess</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">processCustomerData</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataAccess.getCustomerName(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICustomerDataAccess</span> &#123;</span><br><span class="line">    String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerDataAccess</span> <span class="keyword">implements</span> <span class="title class_">ICustomerDataAccess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerDataAccess</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">//get the customer name from the db in real application        </span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dummy Customer Name&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>属性注入</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerBusinessLogic</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerBusinessLogic</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DataAccess.getCustomerName(id);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 包含了公共属性DataAccess，可以在其中设置实现ICustomerDataAccess的实例</span></span><br><span class="line">    <span class="keyword">public</span> ICustomerDataAccess DataAccess &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerService</span> &#123;</span><br><span class="line">    CustomerBusinessLogic customerBusinessLogic;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerService</span><span class="params">()</span> &#123;</span><br><span class="line">        customerBusinessLogic = <span class="keyword">new</span> <span class="title class_">CustomerBusinessLogic</span>();</span><br><span class="line">        customerBusinessLogic.DataAccess = <span class="keyword">new</span> <span class="title class_">CustomerDataAccess</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> customerBusinessLogic.getCustomerName(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>方法注入</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDataAccessDependency</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setDependency</span><span class="params">(ICustomerDataAccess customerDataAccess)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerBusinessLogic</span> <span class="keyword">implements</span> <span class="title class_">IDataAccessDependency</span> &#123;</span><br><span class="line">    ICustomerDataAccess dataAccess;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerBusinessLogic</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataAccess.getCustomerName(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDependency</span><span class="params">(ICustomerDataAccess customerDataAccess)</span> &#123;</span><br><span class="line">        dataAccess = customerDataAccess;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerService</span> &#123;</span><br><span class="line">    CustomerBusinessLogic customerBusinessLogic;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerService</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        customerBusinessLogic = <span class="keyword">new</span> <span class="title class_">CustomerBusinessLogic</span>();</span><br><span class="line">        ((IDataAccessDependency)customerBusinessLogic).setDependency(<span class="keyword">new</span> <span class="title class_">CustomerDataAccess</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomerName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> customerBusinessLogic.getCustomerName(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<hr>
<blockquote>
<h4 id="iterator-pattern迭代器模式"><strong>Iterator
Pattern</strong>：迭代器模式</h4>
<p>变量i的功能抽象化，提供一种方法顺序访问一个聚合对象中的各个元素，而又<strong>不暴露该对象的内部表示</strong></p>
<p>应用：支持对聚合对象的多种遍历；对不同聚合结构提供统一接口；遍历聚合对象并不暴露内部结构</p>
</blockquote>
<hr>
<blockquote>
<h4 id="factory-method工厂方法模式">Factory Method：工厂方法模式</h4>
<p>定义一个<strong>创建对象的接口</strong>，<strong>让子类决定实例化哪个类</strong>，讲一个类的实例化延迟到子类</p>
<p>解决的问题：<strong>创建一个初始化过程较为复杂的对象，并对外隐藏这些细节</strong></p>
<ul>
<li>连接池中的对象，不是每次都创建新的，池大小的参数可以用额外的逻辑控制</li>
<li>希望隐藏对象真实的类型</li>
<li>创建对象需要很多参数，如xml或json</li>
<li>简化常规的创建过程</li>
<li>创建具有复杂依赖关系的对象(Ioc)</li>
<li>无法把握创建的时机</li>
<li>避免在构造函数中抛出异常</li>
</ul>
<p>应用：<strong>框架</strong>使用抽象类定义和维护对象之间的关系，这些对象的创建也通常由框架负责</p>
<ul>
<li>当一个类不知道它所创建的对象的类时</li>
<li>当一个类希望由它的子类来指定它所创建的对象时</li>
<li>可使用<strong>配置文件</strong>指定具体工厂类</li>
</ul>
<p>主要角色：</p>
<ul>
<li>Factory：抽象工厂</li>
<li>Product：抽象产品</li>
<li>ConcreteFactory：具体工厂</li>
<li>ConcreteProduct：具体产品</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>优点：隐藏具体类被实例化的细节，鲜明的<strong>多态</strong>属性，<strong>扩展性好</strong>，符合<strong>开闭原则</strong>。</p>
<p>缺点：每添加一个类，<strong>类的个数成对增加</strong>，会给系统带来一定的额外开销。</p>
<p>参考资料：</p>
<h4 id="工厂模式的本质是什么"><a href="https://www.zhihu.com/question/42975862/answer/1239305317">工厂模式的本质是什么</a></h4>
</blockquote>
<hr>
<blockquote>
<h4 id="prototype原型模式">Prototype：原型模式</h4>
<p>用<strong>原型实例</strong>指定创建对象的种类，并且通过<strong>拷贝</strong>这些原型创建新的对象，可以减少类的数目</p>
<ul>
<li>很多软件的Ctrl+C和Ctrl+V就是原型模式的应用</li>
<li>Java Object中的clone()</li>
</ul>
</blockquote>
<hr>
<blockquote>
<h4 id="builder创建者模式">Builder：创建者模式</h4>
<p>对于复杂的对象，用户只需要指定复杂<strong>对象的类型</strong>就能得到改对象</p>
<p><strong>复杂对象的组合过程外部化</strong>到一个称作创建者的对象里</p>
<p>核心思想：同样的过程，不同的构造</p>
<p>应用场景：</p>
<ul>
<li>构造过程允许构造的对象有不同的表示</li>
<li>创建复杂对象的算法独立于对象的组成部分</li>
</ul>
</blockquote>
<hr>
<blockquote>
<h4 id="abstract-factory抽象工厂模式">Abstract
Factory：抽象工厂模式</h4>
<p>产品族、产品等级结构</p>
</blockquote>
]]></content>
      <tags>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/04/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>序列化和反序列化</title>
    <url>/2022/04/29/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h4 id="序列化和反序列化的定义">序列化和反序列化的定义</h4>
<p><strong>序列化</strong>：把对象转化为可传输的字节序列的过程</p>
<p><strong>反序列化</strong>：把字节序列还原为对象的过程</p>
<hr>
<h4 id="为什么要序列化">为什么要序列化</h4>
<p><strong>目的</strong>：让对象可以<strong>跨平台存储</strong>和进行<strong>网络传输</strong></p>
<p><strong>因果</strong>：网络传输的方式是I/O <span class="math inline">\(\rightarrow\)</span> I/O支持的数据格式为字节数组
<span class="math inline">\(\rightarrow\)</span>
对象要传输需要序列化为字节序列</p>
<p><strong>规范</strong>：序列化需要遵循规则，使得传输到目的地的字节序列能通过该规则反序列化还原为对象</p>
<hr>
<h4 id="需要序列化的场景">需要序列化的场景</h4>
<p>凡是需要<strong>跨平台存储</strong>和<strong>网络传输</strong>的数据，都需要序列化</p>
<p>网络传输本质：对象 <span class="math inline">\(\rightarrow\)</span>
字节序列 <span class="math inline">\(\rightarrow\)</span> 网络 <span class="math inline">\(\rightarrow\)</span> 字节序列 <span class="math inline">\(\rightarrow\)</span> 对象</p>
<p>跨平台存储本质：对象 <span class="math inline">\(\rightarrow\)</span>
跨平台字节码 <span class="math inline">\(\rightarrow\)</span> 跨平台
<span class="math inline">\(\rightarrow\)</span> 跨平台字节码 <span class="math inline">\(\rightarrow\)</span> 对象</p>
<hr>
<h4 id="序列化的选择">序列化的选择</h4>
<p><strong>常见的序列化方式</strong></p>
<p>不支持跨语言：JDK、Kryo、FST</p>
<p>支持跨语言：JSON、Hessian、Thrift、Protostuff</p>
<p><strong>序列化的速度</strong></p>
<p>如果一个项目中需要序列化的场景很多，那么选择序列化效率高的协议能显著提高系统性能</p>
<p><strong>序列化字节序列的大小</strong></p>
<p>数据越小越好，传输快，提升系统性能</p>
<hr>
<h4 id="java中的序列化">Java中的序列化</h4>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java中要实现序列化，只需要实现Serializable接口即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 需要注意的问题</span></span><br><span class="line"><span class="comment"> * 1. static属性不能被序列化</span></span><br><span class="line"><span class="comment"> * 序列化保存的是对象的状态，静态变量属于类的状态，因此序列化不保存静态变量</span></span><br><span class="line"><span class="comment"> * 2. transient属性不会被序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ElemType t;</span><br><span class="line">    <span class="keyword">private</span> ElemType e;    </span><br><span class="line">    <span class="comment">// 经过序列化和反序列化，t中的值会丢失(t == null)，e中的值不会丢失(e == something)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="序列化版本号serialversionuid">序列化版本号serialVersionUID</h4>
<p>所有实现序列化的对象都必须有一个版本号，可以自定义，否则JDK工具会按照对象属性自动生成</p>
<p><strong>版本号的用途</strong></p>
<p>在序列化业务需求发生变化后，通过修改版本号告诉反序列化一方的对象需要同步修改</p>
<p><strong>JDK自动生成的版本号和我们自定义的版本号的区别</strong></p>
<p>JDK根据对象的属性信息生成版本号，意味着对象的属性和序列化版本号会同步改变</p>
<p>坏处：只要对象有一点小变动版本号就会变更，用户必须强制更新软件，而现实需求应该是：<strong>用户可以选择不更新，不更新仅仅无法体验新增加的功能而已</strong>，而这时候就需要我们自定义的版本号了，<strong>只要序列化版本一样，对象新增属性不会影响反序列化对象</strong>。</p>
<hr>
<h4 id="父类子类序列化问题">父类、子类序列化问题</h4>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.父类不实现序列化，子类实现序列化</span></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String hobby;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化后再反序列化</span></span><br><span class="line"><span class="comment">// 最终结果：父类结果未被序列化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.父类实现序列化，子类不实现序列化</span></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String hobby;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化后再反序列化</span></span><br><span class="line"><span class="comment">// 最终结果：子类属性序列化正常</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试概述</title>
    <url>/2022/05/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="软件测试的内涵">软件测试的内涵</h2>
<h3 id="软件测试的重要性">软件测试的重要性</h3>
<p><strong>一、软件系统的层次性越来越复杂，上层系统越来越依赖于底层模块的稳健性</strong></p>
<p><strong>二、软件测试遍布于整个软件生命周期，无处不在</strong></p>
<p>软件测试已经从<u>编码阶段</u>前移到<u>需求分析</u>阶段，甚至前移到可行性论证阶段，同时后置到<u>日常维护阶段</u>，贯穿整个软件生命周期。</p>
<h3 id="软件测试的基本概念">软件测试的基本概念</h3>
<p><strong>一、广义的软件测试</strong></p>
<p>指软件<u>生存周期中所有的检查、评审和确认工作</u>，其中包括了对分析、设计阶段，以及完成开发后维护阶段的各类文档、代码的审查和确认</p>
<p><strong>二、狭义的软件测试</strong></p>
<p><u>识别软件缺陷的过程</u>，即实际结果与预期结果的不一致(常规：最早的测试是编码后的单元测试)</p>
<p><strong>三、软件测试通常包括<u>验证</u>和<u>确认</u></strong></p>
<p>验证(正确性测试)：指保证<u>软件正确地实现了某一特定功能</u>的一系列活动(是否和需求说明书流程一致)</p>
<p>确认(完整性测试)：指保证<u>软件的实现满足了用户需求</u>的一系列活动(是否功能完全覆盖)</p>
<h3 id="软件测试的目的">软件测试的目的</h3>
<p>① 测试的目的是<u>发现软件中的各种缺陷</u></p>
<p>② 测试只能证明软件存在缺陷，<u>不能证明软件不存在缺陷</u></p>
<p>③ 测试可以使软件中缺陷<u>降低到一定程度，而不是彻底消灭</u></p>
<p>④
以<u>较少的用例、时间和人力</u>找出软件中的各种错误和缺陷，以确保软件质量</p>
<p>⑤ 以<u>更少的支出</u>来谋取收入支出比达到最大化</p>
<p>⑥
<strong>最终目标：确保软件功能符合用户需求，把尽可能多的问题在发布或交付前发现并改正</strong></p>
<h3 id="软件测试原则">软件测试原则</h3>
<p>① <strong>选择测试</strong>：权衡投入/产出比</p>
<p>②
<strong>有限测试</strong>：用有限的测试用例保证尽可能大的覆盖程度</p>
<p>③ 所有测试追溯到<strong>用户需求</strong></p>
<p>④ <strong>越早测试越好</strong>，测试过程与开发过程结合</p>
<p>⑤ <strong>测试规模由小到大</strong>，从单元测试到系统测试</p>
<p>⑥ 应由独立第三方来测试</p>
<p>⑦ 不能为了便于测试擅自修改程序</p>
<p>⑧ 测试软件应做什么和不应做什么</p>
<h3 id="软件测试的规律">软件测试的规律</h3>
<p><strong>一 、木桶原理与反木桶原理</strong></p>
<p>①
木桶原理：软件质量的关键因素是分析、设计和实现，测试属于补充检查手段，过度重视测试而忽视其他也会导致软件质量低下</p>
<p>②
反木桶原理：最长的模板决定其特色与优势，能够跳出大集团的游戏规则，独树一帜建立自己的王国</p>
<p><strong>二、Bug的80-20原则</strong></p>
<p>① 80%的工程量用在20%的需求上</p>
<p>② 80%的开发成本花费在20%的部件上</p>
<p>③ 80%的错误是由20%的部件引起的</p>
<p>④ 80%的延期或返工是由20%的变更造成的</p>
<p>⑤ 80%的系统资源是由20%的部件消耗的</p>
<p>⑥ 80%的进度是由20%的人完成的</p>
<h3 id="软件测试的重点">软件测试的重点</h3>
<p><strong>一、<u>测试用例</u>的良好设计</strong></p>
<p><strong>二、<u>测试工作</u>的管理(尤其针对包含多个子系统的测试)</strong></p>
<p><strong>三、<u>测试环境</u>的建立(应与实际环境一致)</strong></p>
<h3 id="软件测试的度量">软件测试的度量</h3>
<p><strong>一、测试覆盖率</strong></p>
<p><strong>二、缺陷发现率</strong></p>
<ul>
<li>缺陷数目</li>
<li>缺陷的严重性</li>
</ul>
<p><strong>三、测试成功率</strong></p>
<ul>
<li>已通过的测试用例的数目</li>
<li>可利用的测试用例的数目</li>
</ul>
<h3 id="软件测试误区和正确理解">软件测试误区和正确理解</h3>
<table>
<colgroup>
<col style="width: 44%">
<col style="width: 55%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">误区</th>
<th>正确理解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">软件开发完成后进行软件测试；软件测试=程序测试</td>
<td>软件测试是整个软件开发全生命周期的事情</td>
</tr>
<tr class="even">
<td style="text-align: left;">软件质量问题是测试人员的错误</td>
<td>软件质量问题是全体项目组共同的事情</td>
</tr>
<tr class="odd">
<td style="text-align: left;">测试技术要求不高，比编程容易，随便找一个人就行</td>
<td>测试人员要求有编程经验和对测试BUG
的敏感性；能够编写自动化测试脚本</td>
</tr>
<tr class="even">
<td style="text-align: left;">测试跟着开发动，有时间就多测，没时间就少测</td>
<td>必须有计划有组织</td>
</tr>
<tr class="odd">
<td style="text-align: left;">测试是测试人员的事，与开发人员无关</td>
<td>开发人员需要自测，还需要沟通协作</td>
</tr>
<tr class="even">
<td style="text-align: left;">软件测试是没有前途的工作，只有程序员才是软件高手</td>
<td>软件测试人员要求的素质往往要超过程序员</td>
</tr>
<tr class="odd">
<td style="text-align: left;">测试要执行所有可能的输入</td>
<td>穷举测试工作量太大，实践上行不通</td>
</tr>
<tr class="even">
<td style="text-align: left;">好的测试一定要使用很多的测试工具</td>
<td>工具所能发挥的作用依赖于使用工具的人</td>
</tr>
</tbody>
</table>
<h2 id="软件测试模型">软件测试模型</h2>
<p><img src="/2022/05/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0/image-20220501234416875.png" alt="image-20220501234416875" style="zoom:80%;"></p>
<h3 id="软件测试技术必考">软件测试技术(必考)</h3>
<h4 id="一黑盒测试-vs-白盒测试从要不要看代码部分来区分">一、黑盒测试 vs
白盒测试：<u>从要不要看代码部分来区分</u></h4>
<blockquote>
<p>黑盒测试，又称功能测试和数据驱动测试，是在<u>已知软件产品具有何种功能</u>的前提下，用来<u>检验每个功能能否正确</u>使用的一个测试方法。</p>
<p>主要工作：检查实现功能与实际需求的满足程度(确认和验证的过程)</p>
<p>测试方法/原理：把程序看作不能打开的黑盒子，在<u>不考虑程序内部结构</u>的情况下，用操作接口的方式进行测试，检验程序能否按照需求制定的功能接受输入数据并产生正确结果。</p>
<figure>
<img src="/2022/05/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0/image-20220501235602507.png" alt="image-20220501235602507">
<figcaption aria-hidden="true">image-20220501235602507</figcaption>
</figure>
<p>黑盒测试主要在<u>开发后期</u>进行。基于对需求、设计、用户要求的理解</p>
</blockquote>
<hr>
<blockquote>
<p>白盒测试，又称结构测试或逻辑驱动测试，<u>必须知道软件内部工作过程</u>，通过测试检测软件内部是否按照需求、设计正常运行。</p>
<p>主要工作：代码检查(语法、逻辑、书写)，静态结构分析(系统结构、函数调用关系)，功能确认与接口分析，逻辑覆盖率分析，性能与效率分析，内存分析</p>
<p>测试方法/原理：通过逻辑覆盖、路径覆盖等方式选择测试用例，可以用<u>测试覆盖率</u>评价测试用例</p>
<figure>
<img src="/2022/05/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0/image-20220502000324686.png" alt="image-20220502000324686">
<figcaption aria-hidden="true">image-20220502000324686</figcaption>
</figure>
</blockquote>
<h4 id="二动态测试-vs-静态测试从要不要运行软件来区分">二、动态测试 vs
静态测试：<u>从要不要运行软件来区分</u></h4>
<blockquote>
<p>静态测试(看代码)：<u>不执行程序</u>来寻找代码种存在的错误或评估代码的过程。由人工进行，发挥人的逻辑思维和测试经验优势。能够批量性发现问题，或直接定位到错误的具体位置。</p>
<p>主要工作：代码检查、静态结构分析、代码质量度量</p>
</blockquote>
<hr>
<blockquote>
<p>动态测试(跑代码)：<u>必须生成测试数据来运行被测试的数据</u>，取得程序运行的真实情况、动态情况。生成测试数据、分析测试结果工作量大、费时、费力、废人</p>
</blockquote>
<h4 id="三手工测试-vs-自动化测试从是否需要人工介入来区分">三、手工测试
vs 自动化测试：<u>从是否需要人工介入来区分</u></h4>
<blockquote>
<p>手工测试：属于传统测试方法，由测试人员手工编写测试用例。缺点是工作量大、重复多，回归测试困难</p>
</blockquote>
<hr>
<blockquote>
<p>自动化测试：利用软件测试工具自动实现全部或部分测试工作：管理、设计、执行和报告。</p>
<p>自动化测试节省大量测试开销，并且能够完成一些手工测试无法实现的测试(如回归测试)。</p>
<p>自动化测试前必须首先手工测试(调试到适合进行自动化测试的环境)</p>
<p>缺点：无法及时进行动态调整和梳理分析(计算正确不代表逻辑没错)</p>
<p>分类：</p>
<ul>
<li>录制/回放：人工完成一遍测试数据，由自动测试工具记录交互过程形成脚本，然后再测试时，直接进行回放。缺点是数据和脚本混在一起，维护成本很高，界面变化时需要重新录入脚本。</li>
</ul>
<p><img src="/2022/05/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0/image-20220502001857268.png" alt="image-20220502001857268" style="zoom:80%;"></p>
<ul>
<li>脚本技术：一组测试工具执行的指令集合。脚本通过录制程序产生脚本，然后再做修改。</li>
<li>数据驱动技术：在脚本技术的基础上，实现数据与脚本分离。</li>
<li><strong>关键字驱动技术(主流)</strong>：在数据驱动的基础上进行改进，将测试逻辑按照关键字进行分解</li>
<li>业务驱动技术：J2EE多层架构技术等</li>
</ul>
</blockquote>
<h2 id="软件测试流程">软件测试流程</h2>
<ol type="1">
<li><p>制定测试大纲；</p></li>
<li><p>制作测试数据；</p></li>
<li><p>单元测试（程序测试）：<strong>白盒测试、功能测试</strong>；</p></li>
<li><p>集成测试（子系统测试）：<strong>白盒和黑盒测试、功能测试</strong>；</p></li>
<li><p>系统测试：<strong>黑盒测试、功能测试、性能测试</strong>；</p></li>
<li><p><strong>回归测试</strong>：<strong>黑盒测试、功能测试、性能测试</strong>；</p></li>
<li><p>验收测试；</p></li>
<li><p>写出测试报告书；</p></li>
<li><p>向下阶段工作提交系统运行、维护手册等。</p></li>
</ol>
<h3 id="v模型重点">V模型(重点)</h3>
<p><img src="/2022/05/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0/image-20220502002729617.png" alt="image-20220502002729617" style="zoom:80%;"></p>
<h3 id="测试流程拆解">测试流程拆解</h3>
<blockquote>
<p>单元测试：完成对<u>最小软件设计单元</u>/模块的验证工作，确保<u>模块被正确地编码</u></p>
<p>测试内容：接口测试、内部数据结构、全局数据结构、<u>边界值分析、语句覆盖、错误路径</u>(处理异常的路径)</p>
<p>测试特点：使用<u>过程设计描述</u>作为指南，对重要控制路径进行测试以发现模块内的错误，通常<u>面向白盒</u></p>
<p>必要性：对代码风格和规则、程序设计和结构、业务逻辑进行测试，<u>尽早发现和解决不易显现的错误</u></p>
</blockquote>
<hr>
<blockquote>
<p>集成测试：通过测试发现<u>与模块接口有关的问题</u>，把通过单元测试的模块构造一个集成的程序结构</p>
<p>测试内容：API、API/参数组合、子模块</p>
<p>测试特点：<u>避免一次性集成，而应采用增量集成</u></p>
</blockquote>
<hr>
<blockquote>
<p>系统测试：根据软件需求规范的要求测试，<u>确认系统满足需求的要求</u></p>
<p>测试内容：所有功能需求得到满足、所有性能需求得到满足、其他需求得到满足</p>
<p>测试特点：系统测试人员相当于<u>用户代言人</u>，需要<u>在需求分析阶段确定软件的可测性</u></p>
</blockquote>
<hr>
<blockquote>
<p>用户验收/确认测试：<strong>配置审查</strong>(确保已开发软件的所有文件资料均已编写齐全，并分类编目)、<strong>Alpha测试</strong>(由用户在开发者的场所进行，测试环境受控)、<strong>Beta测试</strong>(由最终用户在一个或多个用户场所进行，用户记录测试种的问题并报告给开发者)</p>
</blockquote>
<hr>
<blockquote>
<p>回归测试：<u>发现并修改缺陷或软件添加新功能后</u>，重新测试，检查被发现的缺陷是否被改正，并且所作的修改是否引发新的问题</p>
<p>测试方式：<strong>再测试全部用例</strong>(选择基线测试用例库的全部测试用例组成回归测试包，成本极高)，<strong>基于风险选择测试</strong>(基于一定风险标准选择测试用例组成回归测试包)</p>
<p>测试特点：可以通过人工重新执行测试用例，也可以使用自动化测试工具回放进行</p>
</blockquote>
<h2 id="软件测试过程">软件测试过程</h2>
<p>拟定软件<u>测试计划/方案</u> <span class="math inline">\(\rightarrow\)</span> 设计和生成<u>测试用例</u>
<span class="math inline">\(\rightarrow\)</span>
<u>执行测试</u>，记录数据，进行缺陷管理 <span class="math inline">\(\rightarrow\)</span>
生成<u>测试报告</u>，缺陷统计报表</p>
<h3 id="测试计划">测试计划</h3>
<p>① <u>时间进度、人员安排、风险管理</u></p>
<p>② 测试<u>范围的确定</u>、测试<u>数据的生成</u></p>
<p>③ 测试<u>工具、方法的选择</u>和工具开发</p>
<p>④ 测试<u>完成标准</u></p>
<p>⑤ 影响<u>资源分配</u>的特殊考虑</p>
<h3 id="测试方案">测试方案</h3>
<p>定义被测软件功能以及相关的测试，并<u>详细说明的测试方法和策略</u></p>
<h3 id="测试用例">测试用例</h3>
<p>为实施一次测试而<u>向被测系统提供的输入数据、操作或各种环境设置</u>，控制软件测试的执行步骤，对测试方案中每个测试项进一步实例化</p>
<p>基本准则：<u>代表性</u>(等价类划分)、<u>可判定性</u>(都有相应的期望结果)、<u>可再现性</u>(可逆操作)</p>
<h3 id="软件测试的执行">软件测试的执行</h3>
<p>执行测试用例 <span class="math inline">\(\rightarrow\)</span>
记录原始测试数据 <span class="math inline">\(\rightarrow\)</span>
记录缺陷 <span class="math inline">\(\rightarrow\)</span>
对所发现的缺陷进行跟踪</p>
<h3 id="测试评估">测试评估</h3>
<p>结合量化的测试覆盖率及缺陷跟踪报告，<u>对整个软件质量、测试工作和软件缺陷进行总结</u></p>
]]></content>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>黑盒测试(功能性测试)</title>
    <url>/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="等价类划分">等价类划分</h2>
<h3 id="基本概念">基本概念</h3>
<ol type="1">
<li><strong>等价类</strong>：某个输入域的子集合，该子集合<u>揭露的程序错误都是等效的</u>，要么全部被正确处理，要么全部没被正确处理</li>
<li><strong>有效等价类</strong>：有意义的输入数据所构成的集合，用于检测程序是否实现了<u>预期的功能和性能</u></li>
<li><strong>无效等价类</strong>：没有意义的输入数据所构成的结合，用于处理程序<u>对于无效数据的处理能力</u></li>
</ol>
<h3 id="确立等价类的原则">确立等价类的原则</h3>
<ol type="1">
<li><p><strong>按照变量划分</strong>：先按照X划分，再按照Y划分，....，最后形成相应测试用例</p>
<blockquote>
<p>例：A <span class="math inline">\(\leq\)</span> x <span class="math inline">\(\leq\)</span> B，C <span class="math inline">\(\leq\)</span> y <span class="math inline">\(\leq\)</span> D</p>
<p>先按照x划分：</p>
<p>① 有效等价类为：A <span class="math inline">\(\leq\)</span> x <span class="math inline">\(\leq\)</span> B</p>
<p>② 无效等价类为：x &lt; A 和 B &lt; x(两个)</p>
<p>再按照y划分：</p>
<p>① 有效等价类为：C <span class="math inline">\(\leq\)</span> y <span class="math inline">\(\leq\)</span> D</p>
<p>② 无效等价类为：y &lt; C 和 D &lt; y(两个)</p>
</blockquote></li>
<li><p><strong>规定了取值范围</strong> <span class="math inline">\(\rightarrow\)</span>
确立<u>一个有效等价类</u>和<u>两个无效等价类</u></p>
<blockquote>
<p>例：数据范围是1~50</p>
<p>① 有效等价类为 <span class="math inline">\(\geq 1\)</span> &amp;&amp;
$ $</p>
<p>② 无效等价类为 <span class="math inline">\(&lt; 1\)</span> &amp;&amp;
<span class="math inline">\(&gt; 50\)</span></p>
</blockquote></li>
<li><p><strong>输入一个布尔量</strong> <span class="math inline">\(\rightarrow\)</span>
确立<u>一个有效等价类</u>和<u>一个无效等价类</u></p></li>
<li><p><strong>输入一组枚举值</strong> <span class="math inline">\(\rightarrow\)</span>
每个枚举值确立<u>一个有效等价类</u>，剩余值<u>共同确立无效等价类</u></p>
<blockquote>
<p>例：程序输入枚举类型 x = {1, 3, 7, 15}</p>
<p>① 有效等价类为 x = 1,x = 3, x = 7, x = 15</p>
<p>② 无效等价类为 x <span class="math inline">\(\ne\)</span> 1, 3, 7,
15</p>
</blockquote></li>
<li><p><strong>规定数据的规则</strong> <span class="math inline">\(\rightarrow\)</span>
确立<u>一个有效等价类</u>(遵守规则的数据)和<u>若干无效等价类</u></p>
<blockquote>
<p>例：测试密码域，要求密码必须是数字或字母</p>
<p>① 有效等价类为“密码是数字和字母的组合”</p>
<p>② 无效等价类为“密码包括中文，密码包括其他符号”等</p>
</blockquote></li>
</ol>
<h3 id="用例设计">用例设计</h3>
<ol type="1">
<li><p>为每个等价类分别规定一个唯一的编号</p></li>
<li><p>设计一个新的测试用例，<strong>能够尽量覆盖尚未覆盖的有效等价类</strong></p></li>
<li><p>设计一个新的测试用例，<strong>使它仅覆盖一个尚未覆盖的无效等价类</strong></p>
<blockquote>
<p>对于顺序是132还是123的说明：</p>
<p>①
123是先确认功能，后验证功能的正确性，即先确保需求没有遗失，后确认需求是否正确完成。一般是在客户验收阶段，即beta测试</p>
<p>②
132是先找功能是否错误，后确认需求是否满足。一般在系统内部测试阶段，即alpha测试阶段。</p>
</blockquote></li>
</ol>
<h3 id="举例以输入变量确认">举例(以输入变量确认)</h3>
<h4 id="题面">题面</h4>
<p>某保险公司承担人寿保险，该公司保费计算方式为：**保费=投保额*保险率**，保险率依点数不同而有别，10点以上（含10点）费率为0.6%，10点以下费率为0.1%</p>
<p>点数的计算是年龄、性别、婚姻、抚养人数所得的点数的总和</p>
<p>输入：年龄、性别、婚姻、抚养人数</p>
<p>输出：保险率</p>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220502155955725.png" alt="image-20220502155955725" style="zoom:80%;"></p>
<h4 id="第一步输入和输出变量确认">第一步：输入和输出变量确认</h4>
<p>输入：年龄、性别、婚姻、抚养人数</p>
<p>输出：保险率</p>
<p>等价类划分原则：<strong>按照输入变量来确认等价类</strong></p>
<h4 id="第二步等价类划分">第二步：等价类划分</h4>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220502160343829.png" alt="image-20220502160343829" style="zoom: 80%;"></p>
<h4 id="第三步设计测试用例">第三步：设计测试用例</h4>
<ol type="1">
<li><p>设计测试用例，尽可能的覆盖尚未覆盖的有效等价类</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>1</strong></th>
<th style="text-align: center;"><strong>8</strong></th>
<th style="text-align: center;"><strong>10</strong></th>
<th style="text-align: center;"><strong>12</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>2</strong></td>
<td style="text-align: center;"><strong>9</strong></td>
<td style="text-align: center;"><strong>11</strong></td>
<td style="text-align: center;"><strong>13</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>3</strong></td>
<td style="text-align: center;"><strong>8</strong></td>
<td style="text-align: center;"><strong>10</strong></td>
<td style="text-align: center;"><strong>14</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>3</strong></td>
<td style="text-align: center;"><strong>9</strong></td>
<td style="text-align: center;"><strong>10</strong></td>
<td style="text-align: center;"><strong>15</strong></td>
</tr>
</tbody>
</table></li>
<li><p>设计测试用俐，使得每一个新设计的测试用例只包含一个无效等价类</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>4</strong></th>
<th style="text-align: center;"><strong>8</strong></th>
<th style="text-align: center;"><strong>10</strong></th>
<th style="text-align: center;"><strong>12</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>5</strong></td>
<td style="text-align: center;"><strong>9</strong></td>
<td style="text-align: center;"><strong>11</strong></td>
<td style="text-align: center;"><strong>13</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>6</strong></td>
<td style="text-align: center;"><strong>8</strong></td>
<td style="text-align: center;"><strong>10</strong></td>
<td style="text-align: center;"><strong>14</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>7</strong></td>
<td style="text-align: center;"><strong>8</strong></td>
<td style="text-align: center;"><strong>10</strong></td>
<td style="text-align: center;"><strong>14</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>1</strong></td>
<td style="text-align: center;"><strong>8</strong></td>
<td style="text-align: center;"><strong>10</strong></td>
<td style="text-align: center;"><strong>16</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>2</strong></td>
<td style="text-align: center;"><strong>9</strong></td>
<td style="text-align: center;"><strong>11</strong></td>
<td style="text-align: center;"><strong>17</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>3</strong></td>
<td style="text-align: center;"><strong>8</strong></td>
<td style="text-align: center;"><strong>10</strong></td>
<td style="text-align: center;"><strong>18</strong></td>
</tr>
</tbody>
</table></li>
</ol>
<h4 id="第四步选取测试用例">第四步：选取测试用例</h4>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220502160830077.png" style="zoom:80%;"></p>
<h3 id="举例以输出变量确认">举例(以输出变量确认)</h3>
<h4 id="题面-1">题面</h4>
<p>输入3个整数变量a, b,
c，a、b和c均在1—100之间，a、b和c任意2个加起来大于第三个，<u>测试是否为等边三角形、等腰三角形、一般三角形和非三角形</u>。</p>
<h4 id="第一步输入和输出变量确认-1">第一步：输入和输出变量确认</h4>
<p>输入：三个变量(a, b, c)，a、b和c都在1到100之间。</p>
<p>输出：是否为三角形或各类三角形</p>
<blockquote>
<p>输入域情况复杂，很难清晰界定，输出域则较为清晰</p>
</blockquote>
<p>等价类划分原则：<strong>按照输出变量来确认等价类</strong></p>
<h4 id="第二步划分等价类">第二步：划分等价类</h4>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220502161627300.png" alt="image-20220502161627300" style="zoom:80%;"></p>
<h3 id="总结">总结</h3>
<ol type="1">
<li><p>什么时候按照输入域划分，什么时候按照输出域划分？</p>
<p>答：输入变量有清晰的规则，且变量间没有关联关系的情况下按照输入域划分；反之则按照输出域设计测试用例。</p></li>
<li><p>什么情况下使用等价类划分的方法？</p>
<p>答：一般在录入、算法、报表模块使用，因为这些输入变量间没有直接关系。</p></li>
</ol>
<hr>
<h2 id="边界值分析">边界值分析</h2>
<h3 id="基本概念-1">基本概念</h3>
<p>边界值分析就是<u>对输入或输出的边界值进行测试</u>的黑盒测试方法，是等价类划分方法的一种补充，<u>测试用例来自等价类的边界</u></p>
<blockquote>
<p>边界值指的是有效和无效等价类的边界的两个值，两个值逻辑意义上相连，但一个属于有效输入，一个属于无效输入</p>
</blockquote>
<ol type="1">
<li><p>数据范围是<span class="math inline">\(1 \leqslant x \leqslant
50\)</span></p>
<p>边界值取为：<span class="math inline">\(1，50，0，51\)</span></p></li>
<li><p>数据范围是<span class="math inline">\(1 &lt; x &lt;
50\)</span></p>
<p>边界值取为：<span class="math inline">\(1，50，2，49\)</span></p></li>
</ol>
<h3 id="等价类划分和边界值分析的区别">等价类划分和边界值分析的区别</h3>
<blockquote>
<p>例子：测试sqrt()函数</p>
<p>输入：实数</p>
<p>输出：实数</p>
<p>规则：对于输入的值<span class="math inline">\(x\)</span>，当 <span class="math inline">\(x \geq 0\)</span> 时，返回 <span class="math inline">\(\sqrt{x}\)</span>，当 <span class="math inline">\(x &lt; 0\)</span> 时，显示错误信息</p>
<p>一、等价类划分</p>
<p>① 有效等价类： <span class="math inline">\(x \geq 0\)</span> |
无效等价类： <span class="math inline">\(x &lt; 0\)</span></p>
<p>② 测试用例：输入4，输出2 | 输入-10，输出错误信息</p>
<p>二、边界值分析</p>
<p>① 划分 <span class="math inline">\(x \geq 0\)</span>
的边界为0和最大正实数，划分 <span class="math inline">\(x &lt;
0\)</span> 为最小负实数和0</p>
<p>②
测试用例：输入最小负实数、绝对值很小的负数、0、绝对值很小的正数、最大正实数</p>
</blockquote>
<h3 id="举例">举例</h3>
<h4 id="题面-2">题面</h4>
<p>假设商店商品价格[X]皆不大于100元(整数)，若顾客买一件商品，付款[Y]在100元内，求找给顾客的最少货币张数？</p>
<p>货币面值：50元[R50]、20元[R20]、10元[R10]、5元[R5]、2元[R2]、1元[R1]</p>
<h4 id="第一步分析输入">第一步：分析输入</h4>
<p><span class="math inline">\(X &gt; 100\)</span></p>
<p><span class="math inline">\(0 &lt; X \leq 100\)</span></p>
<p><span class="math inline">\(X \leq 0\)</span></p>
<p><span class="math inline">\(Y &gt; 100\)</span></p>
<p><span class="math inline">\(X \leq Y \leq 100\)</span></p>
<p><span class="math inline">\(Y &lt; X\)</span></p>
<h4 id="第二步分析输出">第二步：分析输出</h4>
<p><span class="math inline">\(0 \leq R50 \leq 1\)</span></p>
<p><span class="math inline">\(0 \leq R20 \leq 2\)</span></p>
<p><span class="math inline">\(0 \leq R10 \leq 1\)</span></p>
<p><span class="math inline">\(0 \leq R5 \leq 1\)</span></p>
<p><span class="math inline">\(0 \leq R2 \leq 2\)</span></p>
<p><span class="math inline">\(0 \leq R1 \leq 1\)</span></p>
<h4 id="第三步分析边界">第三步：分析边界</h4>
<p>无效边界：</p>
<p><span class="math inline">\(X &gt; 100\)</span></p>
<p><span class="math inline">\(X \leq 0\)</span></p>
<p><span class="math inline">\(Y &gt; 100\)</span></p>
<p><span class="math inline">\(Y &lt; X\)</span></p>
<p>有效边界：</p>
<p>设找部分钱后剩余的金额为<span class="math inline">\(S\)</span>（初始<span class="math inline">\(S=Y\)</span>）</p>
<p><span class="math inline">\(S \geq 50 找R50\)</span></p>
<p><span class="math inline">\(20 \leq S &lt; 50 找R20\)</span></p>
<p><span class="math inline">\(10 \leq S &lt; 20 找R10\)</span></p>
<p><span class="math inline">\(5 \leq S &lt; 10 找R5\)</span></p>
<p><span class="math inline">\(2 \leq S &lt; 5 找R2\)</span></p>
<p><span class="math inline">\(1 \leq S &lt; 2 找R1\)</span></p>
<h4 id="第四步分析情形">第四步：分析情形</h4>
<p>无效情形：</p>
<p><span class="math inline">\(X &gt; 100\)</span> 错误</p>
<p><span class="math inline">\(X \leq 0\)</span> 错误</p>
<p><span class="math inline">\(0 &lt; X \leq 100, Y &gt; 100\)</span>
错误</p>
<p><span class="math inline">\(0 &lt; X \leq 100, Y &lt; X\)</span>
错误</p>
<p>有效情形：</p>
<p><span class="math inline">\(S =
51,50,49,20,19,10,9,5,4,2,1,0\)</span></p>
<h4 id="第五步设计测试用例">第五步：设计测试用例</h4>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220502165040522.png" alt="image-20220502165040522" style="zoom:80%;"></p>
<h3 id="总结-1">总结</h3>
<ol type="1">
<li><p>对于一个含有<span class="math inline">\(n\)</span>个变量的程序，采用边界值分析法会产生<span class="math inline">\(4n+1\)</span>个测试用例</p>
<blockquote>
<p>对于二元函数<span class="math inline">\(f(x,y)\)</span>，其中 <span class="math inline">\(x \in [1,12]\)</span>，<span class="math inline">\(y \in [1,31]\)</span></p>
<p>采用边界值分析法设计的测试用例是：</p>
<p>{&lt;1,15&gt;,&lt;2,15&gt;,&lt;11,15&gt;,&lt;12,15&gt;,&lt;6,15&gt;,&lt;6,1&gt;,&lt;6,2&gt;,&lt;6,30&gt;,&lt;6,31&gt;}</p>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220502165855510.png" alt="image-20220502165855510" style="zoom:80%;"></p>
</blockquote></li>
<li><p>而如果是健壮性测试用例，需要<span class="math inline">\(6n+1\)</span>个测试用例</p>
<blockquote>
<p>对于二元函数<span class="math inline">\(f(x,y)\)</span>，其中 <span class="math inline">\(x \in [1,12]\)</span>，<span class="math inline">\(y \in [1,31]\)</span></p>
<p>采用边界值分析法设计的测试用例是：</p>
<p>{&lt;0,15&gt;&lt;1,15&gt;,&lt;2,15&gt;,&lt;11,15&gt;,&lt;12,15&gt;,&lt;13,15&gt;,&lt;6,15&gt;,&lt;6,0&gt;&lt;6,1&gt;,&lt;6,2&gt;,&lt;6,30&gt;,&lt;6,31&gt;,&lt;6,32&gt;}</p>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/image-20220502170149026.png" alt="image-20220502170149026" style="zoom:80%;"></p>
</blockquote></li>
<li><p><strong>等价类划分和边界值分析都没有考虑到变量的相关性</strong></p></li>
</ol>
<h2 id="因果图与决策表法">因果图与决策表法</h2>
<h3 id="基本概念-2">基本概念</h3>
<p>一些程序的功能可以用判定表(决策表)的形式来表示，并根据输入条件的组合情况规定相应的操作。而因果图法是<u>利用图解法分析输入的各种组合情况，从而设计测试用例的方法</u>。</p>
<p>基本步骤：</p>
<ol type="1">
<li>根据程序规格说明书，<u>分析并确定因果，画出因果图</u></li>
<li>将得到的<u>因果图转换为判定表</u></li>
<li>为判定表中的每一列所表示的情况<u>设计一个测试用例</u></li>
</ol>
<p>四个组成部分：</p>
<ol type="1">
<li>条件桩：列出问题的所有条件</li>
<li>条件项：针对条件桩给出的条件列出所有可能的取值</li>
<li>动作桩：列出问题规定的可能采取的操作</li>
<li>动作项：指出在条件项的各组取值情况下应采取的动作</li>
</ol>
<p>案例：<strong>第一列</strong>字符必须是<strong>#或</strong>*，<strong>第二列</strong>字符必须是<strong>一个数字</strong>，在此情况下进行文件的修改。但如果第一列字符不正确，则给出<strong>信息L</strong>；如果第二列字符不是数字，则给出<strong>信息M</strong>。</p>
<p>解题步骤：</p>
<ol type="1">
<li>分析程序的规格说明，列出原因和结果。</li>
<li>找出原因与结果之间的因果关系、原因与原因之间的约束关系，画出因果图。</li>
<li>将因果图转换成决策表。</li>
<li>根据(3)中的决策表，设计测试用例的输入数据和预期输出。</li>
</ol>
<p>原因：</p>
<ul>
<li>c1：第一列字符是#</li>
<li>c2：第一列字符是*</li>
<li>c3：第二列字符是一个数字</li>
<li>10：第一列字符是#或*</li>
</ul>
<p>结果：</p>
<ul>
<li>e1：给出信息L</li>
<li>e2：修改文件</li>
<li>e3：给出信息M</li>
</ul>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220402195652141.png" alt="image-20220402195652141" style="zoom: 67%;"></p>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220402202425632.png" alt="image-20220402202425632" style="zoom: 67%;"></p>
<p><img src="/2022/05/02/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220402202454567.png" alt="image-20220402202454567" style="zoom:67%;"></p>
]]></content>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
</search>
